<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Xml" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="Helper.tt" #>
<#@ include file="Core.tt" #>
<#@ output extension=".txt" #>
<#+
	void WriteCSharp()
	{
		this.LaunchDebuggerIfNecessary();
		if (this.CheckInputParameters())
		{
			CodeGenTemplateFileManager templateFileManager = new CodeGenTemplateFileManager(this.GenerationEnvironment);
			templateFileManager.StartHeader();

#>
/*
 * This is a generated file. <#=this.CreatedByToolStatement#>
 * If there are content placeholders, only edit content inside content placeholders.
 * If there are no content placeholders, do not edit this file directly.
 */

<#+
			templateFileManager.EndBlock();

			XDocument xdoc;
			if (string.IsNullOrWhiteSpace(this.DocXmlFilePath))
			{
				xdoc = new XDocument();
			}
			else
			{
				xdoc = XDocument.Load(this.DocXmlFilePath);
			}

			AssemblyReader assemblyReader = new AssemblyReader(this.InputFilePath, null, this.ReferencedAssemblyPaths);
			assemblyReader.Process();

			foreach (ClientCallableTypeInfo type in assemblyReader.Types)
			{
				templateFileManager.StartNewFile(type.Name + ".cs");
				WriteType(type, xdoc, GetExistingFileContent(type.Name + ".cs"));
				templateFileManager.EndBlock();
			}

			templateFileManager.StartNewFile("ErrorCodes.cs");
			WriteErrorCode(assemblyReader.AllErrorCodes, GetExistingFileContent("ErrorCodes.cs"));
			
			templateFileManager.WriteTo(this.OutputDirectory, this.CheckoutCommandPrefix);
		}
	}

	private string[] GetExistingFileContent(string fileName)
    {
		string existingFilePath = System.IO.Path.Combine(this.OutputDirectory, fileName);
		string[] existingFileContent = new string[0];
		if (File.Exists(existingFilePath))
		{
			existingFileContent = File.ReadAllLines(existingFilePath);
		}

		return existingFileContent;
    }

	private void WriteErrorCode(IEnumerable<string> errorCodes, string[] existingFileContent)
	{
#>
using System;

public static class ErrorCodes
{
<#+
		foreach(string errorCode in errorCodes.OrderBy(s => s))
		{
#>
	public const string <#=errorCode#>: string = "<#=errorCode#>";
<#+
		}
#>
}

<#+
	}

	private void WriteType(ClientCallableTypeInfo type, XDocument xdoc, string[] existingFileContent)
	{
		if (type.IsEnum)
		{
			WriteEnumType(type, xdoc, existingFileContent);
		}
		else if (type.IsValueObject)
		{
			WriteClientValueObjectType(type, xdoc, existingFileContent);
		}
		else
		{
			WriteClientObjectType(type, xdoc, existingFileContent);
		}
	}

	private void WriteEnumType(ClientCallableTypeInfo type, XDocument xdoc, string[] existingFileContent)
	{
#>
namespace <#=type.Namespace#>
{
	using System;
<#+
		this.PushIndent(Constants.IndentString);
		this.WritePlaceHolderContent("UsingHeader", existingFileContent);
		this.WriteLine(string.Empty);
		this.WritePlaceHolderContent("Header", existingFileContent);
#>
public static class <#=type.Name#>
{
<#+
		this.PushIndent(Constants.IndentString);
		foreach (KeyValuePair<string, int> field in type.EnumFields)
		{
#>
public const string <#=field.Key#> = "<#=Utility.TrimUnderscore(field.Key)#>";
<#+
		}
		this.PopIndent();
#>
}
<#+
		this.PopIndent();
#>
}
<#+
	}

	private void WriteClientObjectType(ClientCallableTypeInfo type, XDocument xdoc, string[] existingFileContent)
	{
#>
namespace <#=type.Namespace#>
{
	using System;
<#+
		this.PushIndent(Constants.IndentString);
		this.WritePlaceHolderContent("UsingHeader", existingFileContent);
		this.WriteLine(string.Empty);
		this.WritePlaceHolderContent("Header", existingFileContent);
#>
public class <#=type.Name#>: <#=Constants.TypeFullNames.ClientObject#>
{
<#+
		this.PushIndent(Constants.IndentString);
		WriteTypeFields(type);
		this.WriteLine(string.Empty);
		this.WritePlaceHolderContent(type.Name + "_Custom_Members", existingFileContent);
		WriteConstructor(type, xdoc);
		WriteObjectProperties(type, xdoc);
		WriteScalarProperties(type, xdoc);
		WriteMethods(type, xdoc, existingFileContent);
		this.WriteLine(string.Empty);
		WriteHandleResult(type);
		WriteLoadMethod(type);
		if (type.AllowCreation)
		{
			this.WriteLine(string.Empty);
			WriteNewObject(type);
		}
		this.PopIndent();
#>
}
<#+ 
		this.PopIndent();
#>
}
<#+
	}

	private void WriteTypeFields(ClientCallableTypeInfo type)
	{
		foreach (ClientCallablePropertyInfo prop in type.Properties.Where(p => !p.IsVolatile && !p.ExcludedFromClientLibrary))
		{
#>
private <#=CSharpUtility.GetCSharpTypeName(prop.PropertyType)#> <#=prop.FieldName#>;
<#+
		}

		if (type.ClientType.ChildItemClientType != null && type.ClientType.ChildItemClientType.IsClientObject)
		{
#>
private <#=CSharpUtility.GetCSharpTypeName(type.ClientType.ChildItemClientType)#>[] m__items;
<#+
		}
	}

	private void WriteConstructor(ClientCallableTypeInfo type, XDocument xdoc)
    {
#>
public <#=type.Name#>(<#=Constants.TypeFullNames.ClientRequestContext#> context, <#=Constants.TypeFullNames.ObjectPath#> objectPath)
	: base(context, objectPath)
{
}

<#+
    }

	private void WriteObjectProperties(ClientCallableTypeInfo type, XDocument xdoc)
	{
		foreach (ClientCallablePropertyInfo prop in type.ObjectProperties.Where(p => !p.IsVolatile && !p.ExcludedFromClientLibrary))
		{
#>

public <#=CSharpUtility.GetCSharpTypeName(prop.PropertyType)#> <#=prop.Name#>
{
	get
	{
		if (this.<#=prop.FieldName#> == null)
		{
			this.<#=prop.FieldName#> = new <#=CSharpUtility.GetCSharpTypeName(prop.PropertyType)#>(this.Context, <#=CSharpMemberFullNames.CreatePropertyObjectPath#>(this.Context, this, "<#=prop.Name#>", <#=Utility.GetBooleanLiteral(prop.PropertyType.IsClientObjectCollection)#> /*isCollection*/, false /*isInvalidAfterRequest*/));	
		}

		return this.<#=prop.FieldName#>;
	}
<#+
			if (!prop.IsReadonly)
			{
#>

	set
	{
		this.<#=prop.FieldName#> = value;
		<#=CSharpMemberFullNames.CreateSetPropertyAction#>(this.Context, this, "<#=prop.Name#>", value);
	}
<#+	
			}
#>
}
<#+
		}

		foreach (ClientCallablePropertyInfo prop in type.ObjectProperties.Where(p => p.IsVolatile && !p.ExcludedFromClientLibrary))
		{
			this.WriteLine(string.Empty);
#>
public <#=CSharpUtility.GetCSharpTypeName(prop.PropertyType)#> Get<#=prop.Name#>()
{
	return new <#=CSharpUtility.GetCSharpTypeName(prop.PropertyType)#>(this.Context, <#=CSharpMemberFullNames.CreatePropertyObjectPath#>(this.Context, this, "<#=prop.Name#>", <#=Utility.GetBooleanLiteral(prop.PropertyType.IsClientObjectCollection)#> /*isCollection*/, <#=Utility.GetBooleanLiteral(prop.InvalidateReturnObjectPathAfterRequest)#> /*isInvalidAfterRequest*/));
}
<#+
			if (!prop.IsReadonly)
			{
				this.WriteLine(string.Empty);
#>
public void Set<#=prop.Name#>(<#=CSharpUtility.GetCSharpTypeName(prop.PropertyType)#> value)
{
	<#=CSharpMemberFullNames.CreateSetPropertyAction#>(this.Context, this, "<#=prop.Name#>", value);
}
<#+
			}
		}

		// child items
		if (type.ClientType.ChildItemClientType != null && type.ClientType.ChildItemClientType.IsClientObject)
		{
#>

/* Gets the loaded child items in this collection. */
public <#=CSharpUtility.GetCSharpTypeName(type.ClientType.ChildItemClientType)#>[] Items
{
	get
	{
		<#=CSharpMemberFullNames.ThrowIfNotLoaded#>(this, "items", this.m__items);
		return this.m__items;
	}
}
<#+
		}
	}

	private void WriteScalarProperties(ClientCallableTypeInfo type, XDocument xdoc)
	{
		foreach (ClientCallablePropertyInfo prop in type.ScalarProperties.Where(p => !p.ExcludedFromClientLibrary))
		{
			this.WriteLine(string.Empty);
#>
public <#=CSharpUtility.GetCSharpTypeName(prop.PropertyType)#> <#=prop.Name#>
{
	get
	{
		<#=CSharpMemberFullNames.ThrowIfNotLoaded#>(this, "<#=Utility.ToCamelLowerCase(prop.Name)#>", this.<#=prop.FieldName#>);
		return this.<#=prop.FieldName#>;
	}
<#+
			if (!prop.IsReadonly)
			{
				this.WriteLine(string.Empty);
#>
	set
	{
		this.<#=prop.FieldName#> = value;
		<#=CSharpMemberFullNames.CreateSetPropertyAction#>(this.Context, this, "<#=prop.Name#>", value);
	}
<#+	
			}
#>
}
<#+
		}
	}

	private void WriteMethods(ClientCallableTypeInfo type, XDocument xdoc, string[] existingFileContent)
	{
		foreach (ClientCallableMethodInfo method in type.Methods.Where(m => m.ShouldGenerateScriptMethod))
		{
			this.WriteLine(string.Empty);
			if (method.ReturnType.IsClientObject)
			{
				if (method.IsIndexerMethod)
				{
					WriteIndexerMethod(type, method, xdoc, existingFileContent);
				}
				else
				{
					WriteObjectMethod(type, method, xdoc, existingFileContent);
				}
			}
			else
			{
				if (method.ReturnType.IsVoid)
				{
					WriteScalarMethodReturnVoid(type, method, xdoc, existingFileContent);
				}
				else
				{
					WriteScalarMethodReturnValue(type, method, xdoc, existingFileContent);
				}
			}
		}
	}

	private void WriteScalarMethodReturnVoid(ClientCallableTypeInfo type, ClientCallableMethodInfo method, XDocument xdoc, string[] existingFileContent)
	{
#>
public void <#=method.Name#>(<#=BuildMethodParameterList(method)#>)
{
<#+
		this.PushIndent(Constants.IndentString);
		this.WritePlaceHolderContent(type.Name + "_" + method.Name, existingFileContent);
		this.PopIndent();
#>
	<#=CSharpMemberFullNames.CreateMethodAction#>(this.Context, this, "<#=method.Name#>", <#=Constants.TypeFullNames.OperationType#>.<#=method.OperationType#>, <#=BuildMethodParameterValueArray(method)#>);
}
<#+
	}

	private void WriteScalarMethodReturnValue(ClientCallableTypeInfo type, ClientCallableMethodInfo method, XDocument xdoc, string[] existingFileContent)
	{
#>
public <#=Constants.TypeFullNames.ClientResultGenericPrefix#> <#=CSharpUtility.GetCSharpTypeName(method.ReturnType)#> <#=Constants.TypeFullNames.ClientResultGenericSuffix#> <#=method.Name#>(<#=BuildMethodParameterList(method)#>)
{
<#+
		this.PushIndent(Constants.IndentString);
		this.WritePlaceHolderContent(type.Name + "_" + method.Name, existingFileContent);
		this.PopIndent();
#>
	var action = <#=CSharpMemberFullNames.CreateMethodAction#>(this.Context, this, "<#=method.Name#>", <#=Constants.TypeFullNames.OperationType#>.<#=method.OperationType#>, <#=BuildMethodParameterValueArray(method)#>);
	var ret = new <#=Constants.TypeFullNames.ClientResultGenericPrefix#> <#=CSharpUtility.GetCSharpTypeName(method.ReturnType)#> <#=Constants.TypeFullNames.ClientResultGenericSuffix#>();
	<#=CSharpMemberFullNames.AddActionResultHandler#>(this, action, ret);
	return ret;
}
<#+
	}

	private void WriteObjectMethod(ClientCallableTypeInfo type, ClientCallableMethodInfo method, XDocument xdoc, string[] existingFileContent)
	{
#>
public <#=CSharpUtility.GetCSharpTypeName(method.ReturnType)#> <#=method.Name#>(<#=BuildMethodParameterList(method)#>)
{
<#+
		this.PushIndent(Constants.IndentString);
		this.WritePlaceHolderContent(type.Name + "_" + method.Name, existingFileContent);
		this.PopIndent();
#>
	return new <#=CSharpUtility.GetCSharpTypeName(method.ReturnType)#>(this.Context, <#=CSharpMemberFullNames.CreateMethodObjectPath#>(this.Context, this, "<#=method.Name#>", <#=Constants.TypeFullNames.OperationType#>.<#=method.OperationType#>, <#=BuildMethodParameterValueArray(method)#>, <#=Utility.GetBooleanLiteral(method.ReturnType.IsClientObjectCollection)#> /*isCollection*/, <#=Utility.GetBooleanLiteral(method.InvalidateReturnObjectPathAfterRequest)#> /*isInvalidAfterRequest*/));
}
<#+
	}
	
	private void WriteIndexerMethod(ClientCallableTypeInfo type, ClientCallableMethodInfo method, XDocument xdoc, string[] existingFileContent)
	{
#>
public <#=CSharpUtility.GetCSharpTypeName(method.ReturnType)#> <#=method.Name#>(<#=BuildMethodParameterList(method)#>)
{
<#+
		this.PushIndent(Constants.IndentString);
		this.WritePlaceHolderContent(type.Name + "_" + method.Name, existingFileContent);
		this.PopIndent();
#>
	return new <#=CSharpUtility.GetCSharpTypeName(method.ReturnType)#>(this.Context, <#=CSharpMemberFullNames.CreateIndexerObjectPath#>(this.Context, this, <#=BuildMethodParameterValueArray(method)#>));
}
<#+
	}

	private void WriteNewObject(ClientCallableTypeInfo type)
	{
#>
	/*
	 * Create a new instance of <#=CSharpUtility.GetCSharpTypeName(type.ClientType)#> object
	 */
public static static <#=CSharpUtility.GetCSharpTypeName(type.ClientType)#> NewObject(<#=Constants.TypeFullNames.ClientRequestContext#> context) 
{
	var ret = new <#=CSharpUtility.GetCSharpTypeName(type.ClientType)#>(context, <#=CSharpMemberFullNames.CreateNewObjectObjectPath#>(context, "<#=type.FullName#>", <#=Utility.GetBooleanLiteral(type.ClientType.IsClientObjectCollection)#> /*isCollection*/));
	return ret;
} 
<#+
	}

	private string BuildMethodParameterList(ClientCallableMethodInfo method)
	{
		StringBuilder sb = new StringBuilder();
		for (int i = 0; i < method.Parameters.Count; i++)
		{
			ClientCallableParameterInfo param = method.Parameters[i];
			if (i != 0)
			{
				sb.Append(", ");
			}

			if (param.IsParams)
			{
				sb.Append("params ");
			}

			sb.Append(CSharpUtility.GetCSharpTypeName(param.ParameterType));
			sb.Append(" ");
			sb.Append(NormalizeMemberName(param.Name));
		}

		return sb.ToString();
	}

	private string BuildMethodParameterValueArray(ClientCallableMethodInfo method)
	{
		StringBuilder sb = new StringBuilder();
		sb.Append("new object[] {");
		for (int i = 0; i < method.Parameters.Count; i++)
		{
			if (i != 0)
			{
				sb.Append(", ");
			}

			sb.Append(NormalizeMemberName(method.Parameters[i].Name));
		}

		sb.Append("}");
		return sb.ToString();
	}

	private void WriteHandleResult(ClientCallableTypeInfo type)
	{
#>
	/** Handle results returned from the document
	 */
public override void _HandleResult(Newtonsoft.Json.Linq.JToken value)
{
	if (<#=CSharpMemberFullNames.IsNullOrUndefined#>(value))
	{
		return;
	}
	Newtonsoft.Json.Linq.JObject obj = value as Newtonsoft.Json.Linq.JObject;
	if (obj == null)
	{
		return;
	}

	<#=CSharpMemberFullNames.FixObjectPathIfNecessary#>(this, obj);
<#+
		foreach(ClientCallablePropertyInfo prop in type.ScalarProperties.Where(p => !p.ExcludedFromClientLibrary))
		{
#>
	if (!<#=CSharpMemberFullNames.IsUndefined#>(obj["<#=prop.Name#>"]))
	{
		this.LoadedPropertyNames.Add("<#=prop.Name#>");
		this.<#=prop.FieldName#> = obj["<#=prop.Name#>"].ToObject<<#=CSharpUtility.GetCSharpTypeName(prop.PropertyType)#>>();
	}

<#+
		}

		foreach (ClientCallablePropertyInfo prop in type.ObjectProperties.Where(p => !p.IsVolatile && !p.ExcludedFromClientLibrary))
		{
#>
    if (!<#=CSharpMemberFullNames.IsUndefined#>(obj["<#=prop.Name#>"]))
	{
        this.<#=prop.Name#>._HandleResult(obj["<#=prop.Name#>"]);
	}
<#+
		}

		if (type.ClientType.ChildItemClientType != null && type.ClientType.ChildItemClientType.IsClientObject)
		{
			bool hasIndexerMethod = (type.Methods.FirstOrDefault(m => m.IsIndexerMethod) != null);
#>
	Newtonsoft.Json.Linq.JArray itemsData = obj[OfficeExtension.Constants.Items] as Newtonsoft.Json.Linq.JArray;
	if (itemsData != null)
	{
		this.LoadedPropertyNames.Add("items");
		this.m__items = new <#=CSharpUtility.GetCSharpTypeName(type.ClientType.ChildItemClientType)#>[itemsData.Count];
		for (var i = 0; i < itemsData.Count; i++)
		{
			var _item = new <#=CSharpUtility.GetCSharpTypeName(type.ClientType.ChildItemClientType)#>(this.Context, <#=CSharpMemberFullNames.CreateChildItemObjectPathUsingIndexerOrGetItemAt#>(<#=Utility.GetBooleanLiteral(hasIndexerMethod)#>, this.Context, this, itemsData[i], i));
			_item._HandleResult(itemsData[i]);
			this.m__items[i] = _item;
		}
	}
<#+
		}
#>
}
<#+
	}

	private void WriteLoadMethod(ClientCallableTypeInfo type)
	{
		if (!type.IsValueObject)
		{
#>

/*
 * Queues up a command to load the specified properties of the object. You must call "context.sync()" before reading the properties.
 */
public <#=CSharpUtility.GetCSharpTypeName(type.ClientType)#> Load(OfficeExtension.LoadOption option) 
{
	<#=CSharpMemberFullNames.Load#>(this, option);
	return this;
}
<#+
		}
	}

	private void WriteClientValueObjectType(ClientCallableTypeInfo type, XDocument xdoc, string[] existingFileContent)
	{
#>
using System;
namespace <#=type.Namespace#>
{
<#+
		this.PushIndent(Constants.IndentString);
#>
public class <#=type.Name#> 
{
<#+
		this.PushIndent(Constants.IndentString);
		WriteClientValueObjectTypeProperties(type, xdoc);
		this.WriteLine(string.Empty);
		this.WritePlaceHolderContent(type.Name + "_Custom_Members", existingFileContent);
		this.PopIndent();
#>
}
<#+
		this.PopIndent();
#>
}
<#+
	}

	private void WriteClientValueObjectTypeProperties(ClientCallableTypeInfo type, XDocument xdoc)
	{
		foreach (ClientCallablePropertyInfo prop in type.Properties.Where(p => !p.ExcludedFromClientLibrary))
		{
#>
public <#=CSharpUtility.GetCSharpTypeName(prop.PropertyType)#> <#=prop.Name#> { get; set; }
<#+
		}
	}

	private string NormalizeMemberName(string name)
	{
		string[] keywords = new string[] 
			{
				"base",
				"ref",
				"if",
				"yield",
			};

		if (keywords.Contains(name))
		{
			return  name + "_";
		}

		return name;
	}

	private void WriteComments(IEnumerable<string> comments)
	{
		if (comments != null)
		{
			foreach (string line in comments)
			{
				this.WriteLine(line);
			}
		}
	}

	[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1034:NestedTypesShouldNotBeVisible")]
	public static class CSharpMemberFullNames
	{
		public const string CreatePropertyObjectPath = "OfficeExtension.ObjectPathFactory._CreatePropertyObjectPath";
		public const string CreateMethodObjectPath = "OfficeExtension.ObjectPathFactory._CreateMethodObjectPath";
		public const string CreateIndexerObjectPath = "OfficeExtension.ObjectPathFactory._CreateIndexerObjectPath";
		public const string CreateNewObjectObjectPath = "OfficeExtension.ObjectPathFactory._CreateNewObjectObjectPath";
		public const string CreateChildItemObjectPathUsingIndexer = "OfficeExtension.ObjectPathFactory._CreateChildItemObjectPathUsingIndexer";
		public const string CreateChildItemObjectPathUsingGetItemAt = "OfficeExtension.ObjectPathFactory._CreateChildItemObjectPathUsingGetItemAt";
		public const string CreateChildItemObjectPathUsingIndexerOrGetItemAt = "OfficeExtension.ObjectPathFactory._CreateChildItemObjectPathUsingIndexerOrGetItemAt";

		public const string CreateSetPropertyAction = "OfficeExtension.ActionFactory._CreateSetPropertyAction";
		public const string CreateMethodAction = "OfficeExtension.ActionFactory._CreateMethodAction";

		public const string IsNullOrUndefined = "OfficeExtension.Utility._IsNullOrUndefined";
		public const string IsUndefined = "OfficeExtension.Utility._IsUndefined";
		public const string ThrowIfNotLoaded = "OfficeExtension.Utility._ThrowIfNotLoaded";
		public const string Load = "OfficeExtension.Utility._Load";
		public const string FixObjectPathIfNecessary = "OfficeExtension.Utility._FixObjectPathIfNecessary";
		public const string AddActionResultHandler = "OfficeExtension.Utility._AddActionResultHandler";
	}

	public static class CSharpUtility
	{
		public static string GetCSharpTypeName(ClientType type)
		{
			if (type == null)
			{
				throw new ArgumentNullException("type");
			}

			if (type.IsEnum)
			{
				return "string";
			}
			else if (type.IsStream)
			{
				return "string";
			}
			else if (type.IsClientObject || type.IsClientValueObject)
			{
				return type.FullName;
			}
			else if (type.ChildItemClientType != null)
			{
				return GetCSharpTypeName(type.ChildItemClientType) + "[]";
			}
			else
			{
				switch (type.FullName)
				{
					case "System.Object":
						return "object";
					case "System.Int16":
					case "System.UInt16":
					case "System.Int32":
					case "System.UInt32":
						return "int";
					case "System.Single":
					case "System.Double":
						return "double";
					case "System.Boolean":
						return "bool";
					case "System.String":
						return "string";
					default:
						throw CodeGenException.CreateCodeGenException("Cannot handle type {0}", type.FullName);
				}
			}
		}
    }
#>
