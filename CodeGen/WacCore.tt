<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Globalization" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="Helper.tt" #>
<#@ include file="Core.tt" #>
<#@ output extension=".txt" #>

<#+
	void WriteWacFiles()
	{
		LaunchDebuggerIfNecessary();
		if (this.CheckInputParameters())
		{
			AssemblyReader assemblyReader = new AssemblyReader(this.InputFilePath, null, this.ReferencedAssemblyPaths);
			assemblyReader.Process();

			CodeGenTemplateFileManager templateFileManager = new CodeGenTemplateFileManager(this.GenerationEnvironment);
			templateFileManager.StartHeader();
#>
/*
 * This is a generated file. <#=this.CreatedByToolStatement#>
 * If there are content placeholders, only edit content inside content placeholders.
 * If there are no content placeholders, do not edit this file directly.
 */
 <#+
			templateFileManager.EndBlock();
			foreach(ClientCallableTypeInfo type in assemblyReader.Types)
			{
				templateFileManager.StartNewFile(type.Name + ".cs");
				WriteWacType(type, System.IO.Path.Combine(this.OutputDirectory, type.Name + ".cs"));
				templateFileManager.EndBlock();
			}

			templateFileManager.StartNewFile(this.FileBaseName + "TypeReg.cs");
			WriteWacTypeReg(assemblyReader, System.IO.Path.Combine(this.OutputDirectory, this.FileBaseName + "TypeReg.cs"));
			templateFileManager.EndBlock();

			templateFileManager.WriteTo(this.OutputDirectory, this.CheckoutCommandPrefix);
		}
	}

	void WriteWacType(ClientCallableTypeInfo type, string filePath)
	{
		if (type.IsEnum)
		{
			WriteWacTypeEnum(type, filePath);
		}
		else
		{
			WriteWacTypeObject(type, filePath);
		}
	}

	void WriteWacTypeEnum(ClientCallableTypeInfo type, string filePath)
	{
#>
using System;
namespace <#=type.WacNamespace#>
{
	[PreserveName]
	public enum <#=type.Name#>
	{
<#+
		foreach (KeyValuePair<string, int> field in type.EnumFields)
		{

#>
		<#=field.Key#> = <#=field.Value#>,
<#+
		}
#>
	}
}
<#+
	}


	void WriteWacTypeObject(ClientCallableTypeInfo type, string existingHeaderFilePath)
	{
		string[] existingFileContent;
		if (File.Exists(existingHeaderFilePath))
		{
			existingFileContent = File.ReadAllLines(existingHeaderFilePath);
		}
		else
		{
			existingFileContent = new string[0];
		}

		this.WriteLine(string.Empty);
		this.WritePlaceHolderContent("Using", existingFileContent);
		this.WriteLine(string.Empty);
#>
using System;
namespace <#=type.WacNamespace#>
{
	[PreserveName]
	public class <#=type.Name#>
<#+
		this.PushIndent(Constants.IndentString);
		this.PushIndent(Constants.IndentString);
		this.WritePlaceHolderContent("BaseClass", existingFileContent);
		this.PopIndent();
		this.PopIndent();
#>
	{
<#+
		this.PushIndent(Constants.IndentString);
		this.PushIndent(Constants.IndentString);
		this.WritePlaceHolderContent("ClassHeader", existingFileContent);
		this.WriteLine("#region Dispatch IDs");
		this.WriteDispIdDefine(type);
		this.WriteLine("#endregion");
		this.WriteLine(string.Empty);
		this.WritePlaceHolderContent("ClassMembers", existingFileContent);
		this.WriteLine(string.Empty);

		foreach (ClientCallablePropertyInfo prop in type.Properties)
		{
			this.WriteWacProperty(type, prop, existingFileContent);
		}

		foreach (ClientCallableMethodInfo method in type.Methods)
		{
			this.WriteWacMethod(type, method, existingFileContent);
		}

		if (type.ComType.SupportEnumeration)
		{
			this.WriteGetEnumerator(type, existingFileContent);
		}
		this.WriteLine(string.Empty);
		this.WriteLine("#region IDispatch related members");
		this.WriteGetTypeName(type, existingFileContent);
		this.WriteInvokePropertyGet(type, existingFileContent);
		this.WriteInvokePropertyGetAsync(type, existingFileContent);
		this.WriteInvokePropertySet(type, existingFileContent);
		this.WriteInvokePropertySetAsync(type, existingFileContent);
		this.WriteInvokeMethod(type, existingFileContent, false);
		this.WriteInvokeMethod(type, existingFileContent, true);
		this.WriteInvokeMethodHelpers(type, existingFileContent);
		this.WriteLine("#endregion");

		this.WriteLine(string.Empty);
		this.WritePlaceHolderContent("ClassFooter", existingFileContent);
		this.PopIndent();
		this.PopIndent();
#>
	}
}
<#+
	}

	private void WriteDispIdDefine(ClientCallableTypeInfo type)
	{
		foreach(ClientCallableMemberInfo member in type.ComMembers)
		{
#>
private const int DISPID_<#=member.ComMember.Name#> = <#=member.ComMember.DispatchId.ToString(CultureInfo.InvariantCulture)#>;
<#+
		}
	}

	private void WriteGetEnumerator(ClientCallableTypeInfo type, string[] existingFileContent)
	{
#>

/// <summary>
/// Get enumerator
/// </summary>
/// <param name="skip">If its value is greater than zero, it specifies the number of items to skip.</param>
/// <param name="top">If its value is greater than zero, it specifies the number of items to select.</param>
/// <returns>Returs a Promise of OfficeExtension.WacRuntime.IAsyncEnumerator.</returns>
[PreserveName]
public OfficeExtension.IPromise GetAsyncEnumerator(int skip, int top)
{
<#+
		this.PushIndent(Constants.IndentString);
		this.WritePlaceHolderContent("MethodBody_GetAsyncEnumerator", existingFileContent, "return null;");
		this.PopIndent();
#>
}
<#+
	}

	private void WriteWacProperty(ClientCallableTypeInfo type, ClientCallablePropertyInfo prop, string[] existingFileContent)
	{
		if (prop.WacAsync)
		{
			this.WriteWacPropertyAsync(type, prop, existingFileContent);
		}
		else
		{
			this.WriteWacPropertySync(type, prop, existingFileContent);
		}
	}

	private void WriteWacPropertySync(ClientCallableTypeInfo type, ClientCallablePropertyInfo prop, string[] existingFileContent)
	{
		string defaultGetStatement = "return " + Utility.GetWacScriptSharpDefaultValueExpression(prop.PropertyType) + ";";
#>

[PreserveName]
public <#=prop.PropertyType.WacScriptSharpTypeName#> <#=prop.Name#>
{
	get
	{
<#+
		this.PushIndent(Constants.IndentString);
		this.PushIndent(Constants.IndentString);
		this.WritePlaceHolderContent("PropBody_Get" + prop.Name, existingFileContent, defaultGetStatement);
		this.PopIndent();
		this.PopIndent();
#>
	}
<#+
		if (!prop.IsReadonly)
		{
#>
	set
	{
<#+
			this.PushIndent(Constants.IndentString);
			this.PushIndent(Constants.IndentString);
			this.WritePlaceHolderContent("PropBody_Set" + prop.Name, existingFileContent);
			this.PopIndent();
			this.PopIndent();
#>
	}
<#+
		}
#>
}
<#+
	}

	private void WriteWacPropertyAsync(ClientCallableTypeInfo type, ClientCallablePropertyInfo prop, string[] existingFileContent)
	{
#>

[PreserveName]
public OfficeExtension.IPromise Get<#=prop.Name#>()
{
<#+
		this.PushIndent(Constants.IndentString);
		this.WritePlaceHolderContent("PropBody_Get" + prop.Name, existingFileContent, "return null;");
		this.PopIndent();
#>
}
<#+
		if (!prop.IsReadonly)
		{
#>

[PreserveName]
public OfficeExtension.IPromise Set<#=prop.Name#>(<#=prop.PropertyType.WacScriptSharpTypeName#> value)
{
<#+
			this.PushIndent(Constants.IndentString);
			this.WritePlaceHolderContent("PropBody_Set" + prop.Name, existingFileContent, "return null;");
			this.PopIndent();
#>
}
<#+
		}
	}

	private void WriteWacMethod(ClientCallableTypeInfo type, ClientCallableMethodInfo method, string[] existingFileContent)
	{
		StringBuilder sbParams = new StringBuilder();
		foreach (ClientCallableParameterInfo par in method.Parameters)
		{
			if (sbParams.Length > 0)
			{
				sbParams.Append(", ");
			}
			sbParams.Append(par.ParameterType.WacScriptSharpTypeName);
			sbParams.Append(" ");
			sbParams.Append(par.Name);
		}

		string returnType;
		string defaultReturn;
		if (method.WacAsync)
		{
			returnType = "OfficeExtension.IPromise";
			defaultReturn = "return null;";
		}
		else if (method.ReturnType.IsVoid)
		{
			returnType = "void";
			defaultReturn = "return;";
		}
		else
		{
			returnType = method.ReturnType.WacScriptSharpTypeName;
			defaultReturn = "return " + Utility.GetWacScriptSharpDefaultValueExpression(method.ReturnType) + ";";
		}
#>

[PreserveName]
public <#=returnType#> <#=method.WacName#>(<#=sbParams.ToString()#>)
{
<#+
		this.PushIndent(Constants.IndentString);
		this.WritePlaceHolderContent("MethodBody_" + method.Name, existingFileContent, defaultReturn);
		this.PopIndent();
#>
}
<#+
	}

	private void WriteGetTypeName(ClientCallableTypeInfo type, string[] existingFileContent)
	{
#>

[PreserveName]
public string GetTypeName()
{
	return "<#=type.ClientType.TypeRegistrationTypeName#>";
}

<#+
	}

	private void WriteInvokePropertyGet(ClientCallableTypeInfo type, string[] existingFileContent)
	{
#>

[PreserveName]
public object InvokePropertyGet(int dispatchId)
{
<#+
		if (type.Properties.Where(p => !p.WacAsync).Count() > 0)
		{
#>
	switch (dispatchId)
	{
<#+
		foreach (ClientCallablePropertyInfo prop in type.Properties.Where(p => !p.WacAsync))
		{
#>
		case DISPID_<#=prop.ComMember.Name#>:
			return this.<#=prop.Name#>;
<#+
		}
#>
	}
<#+
		}
#>
	throw OfficeExtension.WacRuntime.Utility.CreateApiNotFoundException(dispatchId);
}
<#+
	}

	private void WriteInvokePropertyGetAsync(ClientCallableTypeInfo type, string[] existingFileContent)
	{
#>

[PreserveName]
public OfficeExtension.IPromise InvokePropertyGetAsync(int dispatchId)
{
<#+
		if (type.Properties.Where(p => p.WacAsync).Count() > 0)
		{
#>
	switch (dispatchId)
	{
<#+
		foreach (ClientCallablePropertyInfo prop in type.Properties.Where(p => p.WacAsync))
		{
#>
		case DISPID_<#=prop.ComMember.Name#>:
			return this.Get<#=prop.Name#>();
<#+
		}
#>
	}
<#+
		}
#>

	object ret = this.InvokePropertyGet(dispatchId);
	return OfficeExtension.WacRuntime.Utility.CreatePromiseFromResult(ret);
}
<#+
	}

	private void WriteInvokePropertySet(ClientCallableTypeInfo type, string[] existingFileContent)
	{
#>

[PreserveName]
public void InvokePropertySet(int dispatchId, object[] args)
{
<#+
		if (type.Properties.Where(p =>!p.WacAsync && !p.IsReadonly).Count() > 0)
		{
#>
	switch (dispatchId)
	{
<#+
		foreach (ClientCallablePropertyInfo prop in type.Properties.Where(p => !p.WacAsync && !p.IsReadonly))
		{
#>
		case DISPID_<#=prop.ComMember.Name#>:
			this.<#=prop.Name#> = (<#=prop.PropertyType.WacScriptSharpTypeName#>) OfficeExtension.WacRuntime.Utility.GetAndValidateArgument(args, 0, "<#=Utility.GetWacScriptSharpExptectedScriptType(prop.PropertyType)#>");
			return;
<#+
		}
#>
	}
<#+
		}
#>

	throw OfficeExtension.WacRuntime.Utility.CreateApiNotFoundException(dispatchId);
}
<#+
	}

	private void WriteInvokePropertySetAsync(ClientCallableTypeInfo type, string[] existingFileContent)
	{
#>

[PreserveName]
public OfficeExtension.IPromise InvokePropertySetAsync(int dispatchId, object[] args)
{
<#+
		if (type.Properties.Where(p =>p.WacAsync && !p.IsReadonly).Count() > 0)
		{
#>
	switch (dispatchId)
	{
<#+
		foreach (ClientCallablePropertyInfo prop in type.Properties.Where(p => p.WacAsync && !p.IsReadonly))
		{
#>
		case DISPID_<#=prop.ComMember.Name#>:
			return this.Set<#=prop.Name#>((<#=prop.PropertyType.WacScriptSharpTypeName#>) OfficeExtension.WacRuntime.Utility.GetAndValidateArgument(args, 0, "<#=Utility.GetWacScriptSharpExptectedScriptType(prop.PropertyType)#>"));
<#+
		}
#>
	}
<#+
		}
#>
	this.InvokePropertySet(dispatchId, args);
	return OfficeExtension.WacRuntime.Utility.CreatePromiseFromResult(null);
}
<#+
	}

	private void WriteInvokeMethod(ClientCallableTypeInfo type, string[] existingFileContent, bool asyncMethod)
	{
		string methodReturnType = asyncMethod? "OfficeExtension.IPromise" : "object";
		string methodName = asyncMethod? "InvokeMethodAsync" : "InvokeMethod";
#>

[PreserveName]
public <#=methodReturnType#> <#=methodName#>(int dispatchId, object[] args)
{
<#+
		if (type.Methods.Where(m => m.WacAsync == asyncMethod).Count() > 0)
		{
#>
	switch (dispatchId)
	{
<#+
		foreach (ClientCallableMethodInfo method in type.Methods.Where(m => m.WacAsync == asyncMethod))
		{
#>
		case DISPID_<#=method.ComMember.Name#>:
			return <#=method.Name#>Invoke(args);
<#+
		}
#>
	}
<#+
		}

		if (asyncMethod)
		{
#>
	var ret = this.InvokeMethod(dispatchId, args);
	return OfficeExtension.WacRuntime.Utility.CreatePromiseFromResult(ret);
<#+
		}
		else
		{
#>
	throw OfficeExtension.WacRuntime.Utility.CreateApiNotFoundException(dispatchId);
<#+
		}
#>
}
<#+
	}

	void WriteInvokeMethodHelpers(ClientCallableTypeInfo type, string[] existingFileContent)
	{
		foreach (ClientCallableMethodInfo method in type.Methods)
		{
			string methodReturnType = method.WacAsync? "OfficeExtension.IPromise" : "object";
#>

private <#=methodReturnType#> <#=method.Name#>Invoke(object[] args)
{
<#+
			int index = 0;
			StringBuilder sb = new StringBuilder();
			foreach (ClientCallableParameterInfo par in method.Parameters)
			{
				if (sb.Length > 0)
				{
					sb.Append(", ");
				}

				sb.Append(this.GetArgumentLocalVarName(par));
#>
	<#=par.ParameterType.WacScriptSharpTypeName#> <#=this.GetArgumentLocalVarName(par)#> = (<#=par.ParameterType.WacScriptSharpTypeName#>) OfficeExtension.WacRuntime.Utility.GetAndValidateArgument(args, <#=index.ToString(CultureInfo.InvariantCulture)#>, "<#=Utility.GetWacScriptSharpExptectedScriptType(par.ParameterType)#>");
<#+
				index++;
			}

			if (method.WacAsync)
			{
#>
	return this.<#=method.WacName#>(<#=sb.ToString()#>);
<#+
			}
			else if (method.ReturnType.IsVoid)
			{
#>
	this.<#=method.WacName#>(<#=sb.ToString()#>);
	return null;
<#+
			}
			else
			{
#>
	return this.<#=method.WacName#>(<#=sb.ToString()#>);
<#+
			}
#>
}
<#+
		}
	}

	void WriteWacTypeReg(AssemblyReader reader, string existingFilePath)
	{
		string[] existingFileContent;
		if (File.Exists(existingFilePath))
		{
			existingFileContent = File.ReadAllLines(existingFilePath);
		}
		else
		{
			existingFileContent = new string[0];
		}

		string ns = reader.Types.First().WacNamespace;
		
#>
using System;
using OfficeExtension.WacRuntime;
namespace <#=ns#>
{
	[PreserveName]
	public static class TypeRegister
	{
		[PreserveName]
		public static void RegisterTypes(ITypeRegistration typeReg)
		{
			ITypeInformation typeInfo;
			IMethodInformation methodInfo;
			IPropertyInformation propInfo;
<#+
		foreach (ClientCallableTypeInfo type in reader.Types)
		{
			if (type.IsEnum)
			{
#>
			typeInfo = typeReg.AddEnumType("<#=type.FullName#>");
<#+
				foreach(KeyValuePair<string, int> pair in type.EnumFields)
				{
#>
			typeInfo.AddEnumField("<#=Utility.TrimUnderscore(pair.Key)#>", <#=pair.Value#>);
<#+
				}
			}
			else
			{
				string classId = string.Empty;
				if (type.CoClassId != Guid.Empty)
				{
					classId = type.CoClassId.ToString("B");
				}

#>
			typeInfo = typeReg.AddType("<#=type.FullName#>", "<#=type.InterfaceId.ToString("B")#>", "<#=classId#>");
<#+
				foreach (ClientCallablePropertyInfo prop in type.Properties)
				{
#>
			propInfo = typeInfo.AddProperty("<#=prop.Name#>", <#=prop.ComMember.DispatchId.ToString(CultureInfo.InvariantCulture)#>, "<#=prop.PropertyType.TypeRegistrationTypeName#>", TypeCategory.<#=prop.PropertyType.TypeRegistrationTypeCategory#>, <#=prop.IsReadonly? "true" :"false"#>);
<#+
				}

				foreach (ClientCallableMethodInfo method in type.Methods)
				{
					if (method.IsIndexerMethod)
					{
#>
			methodInfo = typeInfo.AddIndexerMethod(<#=method.ComMember.DispatchId.ToString(CultureInfo.InvariantCulture)#>, "<#=method.ReturnType.TypeRegistrationTypeName#>", TypeCategory.<#=method.ReturnType.TypeRegistrationTypeCategory#>);
<#+
					}
					else
					{
#>
			methodInfo = typeInfo.AddMethod("<#=method.Name#>", <#=method.ComMember.DispatchId.ToString(CultureInfo.InvariantCulture)#>, "<#=method.ReturnType.TypeRegistrationTypeName#>", TypeCategory.<#=method.ReturnType.TypeRegistrationTypeCategory#>, OperationType.<#=method.OperationType == ClientCallableOperationType.Default ? "DefaultValue" : method.OperationType.ToString()#>, "<#=method.RESTfulName#>");
<#+
					}

					foreach(ClientCallableParameterInfo par in method.Parameters)
					{
#>
			methodInfo.AddParameter("<#=par.Name#>", "<#=par.ParameterType.TypeRegistrationTypeName#>", TypeCategory.<#=par.ParameterType.TypeRegistrationTypeCategory#>);
<#+
					}
				}
			}

			if (type.IsClientObject)
			{
				if (!string.IsNullOrEmpty(type.CreateItemOperationName) ||
					!string.IsNullOrEmpty(type.DeleteOperationName))
				{
#>
			typeInfo.SetRESTfulOperationMethodNames("<#=type.CreateItemOperationName ?? string.Empty#>", "<#=type.DeleteOperationName ?? string.Empty#>");
<#+
				}

				if (type.ClientType.ChildItemClientType != null)
				{
#>
			typeInfo.SetCollectionInfo("<#=type.ClientType.ChildItemClientType.TypeRegistrationTypeName#>", <#=Utility.GetBooleanLiteral(type.ComType.SupportEnumeration)#>);
<#+
				}
			}
		}
#>
		}
	}
}
<#+
	}

	string GetArgumentLocalVarName(ClientCallableParameterInfo par)
	{
		return "var" + Utility.ToCamelUpperCase(par.Name);
	}

	string[] GetExistingFileContent(string existingFilePath)
	{
		string[] existingFileContent = new string[0];
		if (File.Exists(existingFilePath))
		{
			existingFileContent = File.ReadAllLines(existingFilePath);
		}
		return existingFileContent;
	}
#>
