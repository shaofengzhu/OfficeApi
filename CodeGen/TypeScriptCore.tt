<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Xml" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="Helper.tt" #>
<#@ include file="Core.tt" #>
<#@ output extension=".txt" #>
<#+
	void WriteTypeScript()
	{
		this.LaunchDebuggerIfNecessary();
		if (this.CheckInputParameters())
		{
			CodeGenTemplateFileManager templateFileManager = new CodeGenTemplateFileManager(this.GenerationEnvironment);
			templateFileManager.StartHeader();

#>
/*
 * This is a generated file. <#=this.CreatedByToolStatement#>
 * If there are content placeholders, only edit content inside content placeholders.
 * If there are no content placeholders, do not edit this file directly.
 */

<#+
			templateFileManager.EndBlock();

			templateFileManager.StartNewFile(this.FileBaseName + this.FileNamePostfix + ".ts");
			this.WriteTypeScriptBody(System.IO.Path.Combine(this.OutputDirectory, this.FileBaseName + this.FileNamePostfix + ".ts"));
			templateFileManager.EndBlock();
			
			templateFileManager.WriteTo(this.OutputDirectory, this.CheckoutCommandPrefix);
		}
	}

	void WriteTypeScriptBody(string existingFilePath)
	{
		string[] existingFileContent = new string[0];
		if (File.Exists(existingFilePath))
		{
			existingFileContent = File.ReadAllLines(existingFilePath);
		}

		this.WriteLine(string.Empty);
		this.WritePlaceHolderContent("GlobalHeader", existingFileContent);
		this.WriteLine(string.Empty);

		XDocument xdoc;
		if (string.IsNullOrWhiteSpace(this.DocXmlFilePath))
		{
			xdoc = new XDocument();
		}
		else
		{
			xdoc = XDocument.Load(this.DocXmlFilePath);
		}

		string validateApiSetsParamValue = this.GetParameterValue("ValidateApiSetAnnotations");
		if (!string.IsNullOrWhiteSpace(validateApiSetsParamValue))
		{
			Utility.ValidateApiSetAnnotations = Boolean.Parse(validateApiSetsParamValue);
		}

		Utility.ApiSetDefaultName = this.GetParameterValue("ApiSetDefaultName");
		AssemblyReader assemblyReader = new AssemblyReader(this.InputFilePath, null, this.ReferencedAssemblyPaths, this.MaxVersion);
		assemblyReader.Process();
		List<string> namespaceStack = new List<string>();
		bool first = true;
		foreach (ClientCallableTypeInfo type in assemblyReader.Types)
		{
			this.EnsureNamespace(namespaceStack, type.TypescriptNamespace, forTypeScript: true, indentString: Constants.IndentString);
			if (first)
			{
				this.WritePlaceHolderContent("ModuleHeader", existingFileContent);
				this.WriteMethodAlias();
				first = false;
			}
			WriteType(type, xdoc, existingFileContent);
		}

		WriteErrorCode(assemblyReader.AllErrorCodes);

		this.EnsureNamespace(namespaceStack, string.Empty, forTypeScript: true, indentString: Constants.IndentString);
		this.WriteLine(string.Empty);
		this.WritePlaceHolderContent("GlobalFooter", existingFileContent);
		this.WriteLine(string.Empty);
		WriteStatistics(assemblyReader);
	}

	private void WriteMethodAlias()
	{
#>

var _createPropertyObjectPath = OfficeExtension.ObjectPathFactory.createPropertyObjectPath;
var _createMethodObjectPath = OfficeExtension.ObjectPathFactory.createMethodObjectPath;
var _createIndexerObjectPath = OfficeExtension.ObjectPathFactory.createIndexerObjectPath;
var _createNewObjectObjectPath = OfficeExtension.ObjectPathFactory.createNewObjectObjectPath;
var _createChildItemObjectPathUsingIndexer = OfficeExtension.ObjectPathFactory.createChildItemObjectPathUsingIndexer;
var _createChildItemObjectPathUsingGetItemAt = OfficeExtension.ObjectPathFactory.createChildItemObjectPathUsingGetItemAt;
var _createChildItemObjectPathUsingIndexerOrGetItemAt = OfficeExtension.ObjectPathFactory.createChildItemObjectPathUsingIndexerOrGetItemAt;
var _createMethodAction = OfficeExtension.ActionFactory.createMethodAction;
var _createSetPropertyAction = OfficeExtension.ActionFactory.createSetPropertyAction;
var _isNullOrUndefined = OfficeExtension.Utility.isNullOrUndefined;
var _isUndefined = OfficeExtension.Utility.isUndefined;
var _throwIfNotLoaded = <any>OfficeExtension.Utility.throwIfNotLoaded; // Cast to "any" so that can accept either 2 OR 3 arguments in older (in-branch) Utility.ts code. Can remove this eventually when code has FI-ed, though no harm in leaving it as is, either.
var _load = OfficeExtension.Utility.load;
var _fixObjectPathIfNecessary = OfficeExtension.Utility.fixObjectPathIfNecessary;
var _addActionResultHandler = OfficeExtension.Utility._addActionResultHandler;
var _handleNavigationPropertyResults = OfficeExtension.Utility._handleNavigationPropertyResults;
var _adjustToDateTime = OfficeExtension.Utility.adjustToDateTime;
<#+
	}

	private void WriteStatistics(AssemblyReader assemblyReader)
	{
		Console.WriteLine();
		Console.WriteLine("---Statistics Begin---");
		int typeCount = 0;
		int propertyGetCount = 0;
		int propertySetCount = 0;
		int methodCount = 0;

		foreach (ClientCallableTypeInfo type in assemblyReader.Types)
		{
			typeCount++;
			propertyGetCount += type.Properties.Count;
			propertySetCount += type.Properties.Where(p => p.IsReadonly).Count();
			methodCount += type.Methods.Count;
		}

		Console.WriteLine("Types={0}", typeCount);
		Console.WriteLine("Property Getter={0}", propertyGetCount);
		Console.WriteLine("Property Setter={0}", propertySetCount);
		Console.WriteLine("Methods={0}", methodCount);
		Console.WriteLine("---Statistics End---");
		Console.WriteLine();
	}
#>

<#+
	private void WriteErrorCode(IEnumerable<string> errorCodes)
	{
#>

export module ErrorCodes
{
<#+
		foreach(string errorCode in errorCodes.OrderBy(s => s))
		{
#>
	export var <#=Utility.ToCamelLowerCase(errorCode)#>: string = "<#=errorCode#>";
<#+
		}
#>
}

<#+
	}

	private void WriteType(ClientCallableTypeInfo type, XDocument xdoc, string[] existingFileContent)
	{
		if (Utility.ShouldSkipWritingTypeInterface(type))
		{
			return;
		}

		this.WriteLine(string.Empty);
		this.WriteComments(Utility.BuildJsDocForType(type, xdoc));

		if (type.IsEnum)
		{
			WriteEnumType(type, xdoc);
		}
		else if (type.IsValueObject)
		{
			WriteClientValueObjectType(type, xdoc, existingFileContent);
		}
		else
		{
			WriteClientObjectType(type, xdoc, existingFileContent);
		}
	}

	private void WriteEnumType(ClientCallableTypeInfo type, XDocument xdoc)
	{
#>
export module <#=type.Name#>
{
<#+
		foreach (KeyValuePair<string, int> field in type.EnumFields)
		{
			this.WriteLine(string.Empty);
			this.PushIndent(Constants.IndentString);
			this.WriteComments(Utility.BuildJsDocForEnumField(type, field.Key, xdoc));
			this.PopIndent();
#>
	export var <#=Utility.ToCamelLowerCase(field.Key)#> : string = "<#=Utility.TrimUnderscore(field.Key)#>";
<#+
		}
#>
}
<#+
	}

	private void WriteClientObjectType(ClientCallableTypeInfo type, XDocument xdoc, string[] existingFileContent)
	{
		string typeNameOrCustom = string.IsNullOrEmpty(type.CustomTypeScriptTypeName) ? type.Name : type.CustomTypeScriptTypeName;
#>
export class <#= typeNameOrCustom #> extends <#=Constants.TypeFullNames.ClientObject#> {
<#+
		WriteTypeFields(type);
		this.WriteLine(string.Empty);
		this.PushIndent(Constants.IndentString);
		this.WritePlaceHolderContent(type.Name + "_Custom_Members", existingFileContent);
		this.PopIndent();
		WriteObjectProperties(type, xdoc, existingFileContent);
		WriteScalarProperties(type, xdoc, existingFileContent);
		WriteMethods(type, xdoc, existingFileContent);
		this.WriteLine(string.Empty);
		WriteHandleResult(type);
		WriteLoadMethod(type);
		WriteHandleIdResultMethod(type);
		if (type.AllowCreation)
		{
			this.WriteLine(string.Empty);
			WriteNewObject(type);
		}

		WriteEvents(type, xdoc, existingFileContent);
		this.WriteTrackUntrack(type);
		this.WriteLine(string.Empty);
		WriteToJson(type);
#>
}
<#+
	}

	private void WriteToJson(ClientCallableTypeInfo type)
	{
		var stringifiableProperties = type.Properties
		.Where(
			p => p.IncludeInJsonStringify
				/* NOTE: the property access above will check (throw) for incorrect usage (i.e., is a collection type
					is simulatneously marked for exclusion from client library, has a name that starts with an underscore, etc.) */
		)
		.OrderBy(item => item.Name)
		.ToList();
#>
	toJSON() {
		return {
<#+
			for (var i = 0; i < stringifiableProperties.Count; i++) {
				var commaOrNothing = (i + 1 < stringifiableProperties.Count) ? ",": String.Empty;
#>
			"<#= Utility.ToCamelLowerCase(stringifiableProperties[i].Name) #>": this.<#= stringifiableProperties[i].FieldName #><#= commaOrNothing #>
<#+
			}
#>
		};
	}
<#+
	}

	private void WriteTypeFields(ClientCallableTypeInfo type)
	{
		foreach (ClientCallablePropertyInfo prop in type.Properties.Where(p => !p.IsVolatile && !p.ExcludedFromClientLibrary))
		{
			var comments = new List<string>();
			if (!prop.IncludeInJsonStringify)
			{
				comments.Add("NOT JSON-stringifiable");
			}

			var commentStringIfAny = comments.Any() ? (" /* { " + String.Join(", ", comments) + " } */") : string.Empty;
#>
	private m_<#=Utility.ToCamelLowerCase(prop.Name)#> : <#=prop.PropertyType.TypeScriptTypeName#>;<#= commentStringIfAny #>
<#+
		}

		foreach (ClientCallableEventInfo evt in type.Events)
		{
#>
	private m_<#=Utility.ToCamelLowerCase(evt.Name)#>: <#=Constants.TypeFullNames.EventHandlers#>< <#=Utility.GetTypeScriptTypeName(evt.EventArgsType)#> >;
<#+
		}

		if (type.ClientType.ChildItemClientType != null && type.ClientType.ChildItemClientType.IsClientObject)
		{
#>
	private m__items: Array< <#=type.ClientType.ChildItemClientType.TypeScriptTypeName#> >;
<#+
		}
	}

	private void WriteObjectProperties(ClientCallableTypeInfo type, XDocument xdoc, string[] existingFileContent)
	{
		foreach (ClientCallablePropertyInfo prop in type.ObjectProperties.Where(p => !p.IsVolatile && !p.ExcludedFromClientLibrary))
		{
			this.PushIndent(Constants.IndentString);
			this.WriteComments(Utility.BuildJsDocForProperty(type, prop, xdoc));
			this.PopIndent();
#>

	get <#=Utility.ToCamelLowerCase(prop.Name)#>(): <#=prop.PropertyType.TypeScriptTypeName#>{
<#+
			this.PushIndent(Constants.IndentString);
			this.PushIndent(Constants.IndentString);
			this.WritePlaceHolderContent(type.Name + "_" + prop.Name + "_get", existingFileContent);
			this.PopIndent();
			this.PopIndent();
#>
		if (!this.<#=prop.FieldName#>){
			this.<#=prop.FieldName#> = new <#=prop.PropertyType.TypeScriptTypeName#>(this.context, <#=Constants.MemberFullNames.CreatePropertyObjectPath#>(this.context, this, "<#=prop.Name#>", <#=Utility.GetBooleanLiteral(prop.PropertyType.IsClientObjectCollection)#> /*isCollection*/, false /*isInvalidAfterRequest*/));
		}
		return this.<#=prop.FieldName#>;
	}
<#+
			if (!prop.IsReadonly)
			{
				// NOTE: Do *NOT* write JSDOC comments on setters. Doing so creates a doubled-up comment on the property in the final TypeScript / d.ts file.
				// Just writing the JSDOC comment on the getter is perfectly sufficient (and our underlying assumption is that there are
				// no such things as write-only properties -- that same assumption is already used above, when creating the getter).
#>

	set <#=Utility.ToCamelLowerCase(prop.Name)#>(value: <#=prop.PropertyType.TypeScriptTypeName#>){
<#+
			this.PushIndent(Constants.IndentString);
			this.PushIndent(Constants.IndentString);
			this.WritePlaceHolderContent(type.Name + "_" + prop.Name + "_set", existingFileContent);
			this.PopIndent();
			this.PopIndent();
#>
		this.<#=prop.FieldName#> = value;
		<#=Constants.MemberFullNames.CreateSetPropertyAction#>(this.context, this, "<#=prop.Name#>", value);
	}
<#+	
			}
		}

		foreach (ClientCallablePropertyInfo prop in type.ObjectProperties.Where(p => p.IsVolatile && !p.ExcludedFromClientLibrary))
		{
			this.WriteLine(string.Empty);
			this.PushIndent(Constants.IndentString);
			this.WriteComments(Utility.BuildJsDocForProperty(type, prop, xdoc));
			this.PopIndent();
#>
	get<#=Utility.ToCamelUpperCase(prop.Name)#>(): <#=prop.PropertyType.TypeScriptTypeName#>{
<#+
			this.PushIndent(Constants.IndentString);
			this.PushIndent(Constants.IndentString);
			this.WritePlaceHolderContent(type.Name + "_" + prop.Name + "_get", existingFileContent);
			this.PopIndent();
			this.PopIndent();
#>
		return new <#=prop.PropertyType.TypeScriptTypeName#>(this.context, <#=Constants.MemberFullNames.CreatePropertyObjectPath#>(this.context, this, "<#=prop.Name#>", <#=Utility.GetBooleanLiteral(prop.PropertyType.IsClientObjectCollection)#> /*isCollection*/, <#=Utility.GetBooleanLiteral(prop.InvalidateReturnObjectPathAfterRequest)#> /*isInvalidAfterRequest*/));
	}
<#+
			if (!prop.IsReadonly)
			{
				this.WriteLine(string.Empty);
				// NOTE: Do *NOT* write JSDOC comments on setters. Doing so creates a doubled-up comment on the property in the final TypeScript / d.ts file.
				// Just writing the JSDOC comment on the getter is perfectly sufficient (and our underlying assumption is that there are
				// no such things as write-only properties -- that same assumption is already used above, when creating the getter).
#>
	set<#=Utility.ToCamelUpperCase(prop.Name)#>(value: <#=prop.PropertyType.TypeScriptTypeName#>){
<#+
			this.PushIndent(Constants.IndentString);
			this.PushIndent(Constants.IndentString);
			this.WritePlaceHolderContent(type.Name + "_" + prop.Name + "_set", existingFileContent);
			this.PopIndent();
			this.PopIndent();
#>
		<#=Constants.MemberFullNames.CreateSetPropertyAction#>(this.context, this, "<#=prop.Name#>", value);
	}
<#+
			}
		}

		// child items
		if (type.ClientType.ChildItemClientType != null && type.ClientType.ChildItemClientType.IsClientObject)
		{
#>

	/** Gets the loaded child items in this collection. */
	get items(): Array< <#=type.ClientType.ChildItemClientType.TypeScriptTypeName#> > {
<#+
			this.PushIndent(Constants.IndentString);
			this.PushIndent(Constants.IndentString);
			this.WritePlaceHolderContent(type.Name + "_items", existingFileContent);
			this.PopIndent();
			this.PopIndent();
#>

		<#=Constants.MemberFullNames.ThrowIfNotLoaded#>("items", this.m__items, "<#= type.Name #>", this._isNull);
		return this.m__items;
	}
<#+
		}
	}

	private void WriteScalarProperties(ClientCallableTypeInfo type, XDocument xdoc, string[] existingFileContent)
	{
		foreach (ClientCallablePropertyInfo prop in type.ScalarProperties.Where(p => !p.ExcludedFromClientLibrary))
		{
			this.WriteLine(string.Empty);
			this.PushIndent(Constants.IndentString);
			this.WriteComments(Utility.BuildJsDocForProperty(type, prop, xdoc));
			this.PopIndent();
#>
	get <#=Utility.ToCamelLowerCase(prop.Name)#>(): <#=prop.PropertyType.TypeScriptTypeName#>{
<#+
			this.PushIndent(Constants.IndentString);
			this.PushIndent(Constants.IndentString);
			this.WritePlaceHolderContent(type.Name + "_" + prop.Name + "_get", existingFileContent);
			this.PopIndent();
			this.PopIndent();
#>
		<#=Constants.MemberFullNames.ThrowIfNotLoaded#>("<#=Utility.ToCamelLowerCase(prop.Name)#>", this.<#=prop.FieldName#>, "<#= type.Name #>", this._isNull);
		return this.<#=prop.FieldName#>;
	}
<#+
			if (!prop.IsReadonly)
			{
				this.WriteLine(string.Empty);
				// NOTE: Do *NOT* write JSDOC comments on setters. Doing so creates a doubled-up comment on the property in the final TypeScript / d.ts file.
				// Just writing the JSDOC comment on the getter is perfectly sufficient (and our underlying assumption is that there are
				// no such things as write-only properties -- that same assumption is already used above, when creating the getter).
#>
	set <#=Utility.ToCamelLowerCase(prop.Name)#>(value: <#=prop.PropertyType.TypeScriptTypeName#>){
<#+
			this.PushIndent(Constants.IndentString);
			this.PushIndent(Constants.IndentString);
			this.WritePlaceHolderContent(type.Name + "_" + prop.Name + "_set", existingFileContent);
			this.PopIndent();
			this.PopIndent();
#>
		this.<#=prop.FieldName#> = value;
		<#=Constants.MemberFullNames.CreateSetPropertyAction#>(this.context, this, "<#=prop.Name#>", value);
	}
<#+	
			}
		}
	}

	private void WriteMethods(ClientCallableTypeInfo type, XDocument xdoc, string[] existingFileContent)
	{
		foreach (ClientCallableMethodInfo method in type.Methods.Where(m => m.ShouldGenerateScriptMethod))
		{
			this.WriteLine(string.Empty);
			this.PushIndent(Constants.IndentString);
			this.WriteComments(Utility.BuildJsDocForMethod(type, method, xdoc));
			this.PopIndent();
			if (method.ReturnType.IsClientObject)
			{
				if (method.IsIndexerMethod)
				{
					WriteIndexerMethod(type, method, xdoc, existingFileContent);
				}
				else
				{
					WriteObjectMethod(type, method, xdoc, existingFileContent);
				}
			}
			else
			{
				if (method.ReturnType.IsVoid)
				{
					WriteScalarMethodReturnVoid(type, method, xdoc, existingFileContent);
				}
				else
				{
					WriteScalarMethodReturnValue(type, method, xdoc, existingFileContent);
				}
			}
		}
	}

	private void WriteScalarMethodReturnVoid(ClientCallableTypeInfo type, ClientCallableMethodInfo method, XDocument xdoc, string[] existingFileContent)
	{
#>
	<#=Utility.ToCamelLowerCase(method.Name)#>(<#=BuildMethodParameterList(method)#>): void {
<#+
		this.PushIndent(Constants.IndentString);
		this.PushIndent(Constants.IndentString);
		this.WritePlaceHolderContent(type.Name + "_" + method.Name, existingFileContent);
		this.PopIndent();
		this.PopIndent();
#>
		<#=Constants.MemberFullNames.CreateMethodAction#>(this.context, this, "<#=method.Name#>", <#=Constants.TypeFullNames.OperationType#>.<#=method.OperationType#>, <#=BuildMethodParameterValueArray(method)#>);
	}
<#+
	}

	private void WriteScalarMethodReturnValue(ClientCallableTypeInfo type, ClientCallableMethodInfo method, XDocument xdoc, string[] existingFileContent)
	{
#>
	<#=Utility.ToCamelLowerCase(method.Name)#>(<#=BuildMethodParameterList(method)#>): <#=Constants.TypeFullNames.ClientResultGenericPrefix#> <#=method.ReturnType.TypeScriptTypeName#> <#=Constants.TypeFullNames.ClientResultGenericSuffix#>{
<#+
		this.PushIndent(Constants.IndentString);
		this.PushIndent(Constants.IndentString);
		this.WritePlaceHolderContent(type.Name + "_" + method.Name, existingFileContent);
		this.PopIndent();
		this.PopIndent();
		string clientResultType = "";
		if (method.ReturnType.IsDateTimeOrDateTimeArray)
		{
			clientResultType = "OfficeExtension.ClientResultProcessingType.date";
		}
#>
		var action = <#=Constants.MemberFullNames.CreateMethodAction#>(this.context, this, "<#=method.Name#>", <#=Constants.TypeFullNames.OperationType#>.<#=method.OperationType#>, <#=BuildMethodParameterValueArray(method)#>);
		var ret = new <#=Constants.TypeFullNames.ClientResultGenericPrefix#> <#=method.ReturnType.TypeScriptTypeName#> <#=Constants.TypeFullNames.ClientResultGenericSuffix#>(<#=clientResultType#>);
		<#=Constants.MemberFullNames.AddActionResultHandler#>(this, action, ret);
		return ret;
	}
<#+
	}

	private void WriteObjectMethod(ClientCallableTypeInfo type, ClientCallableMethodInfo method, XDocument xdoc, string[] existingFileContent)
	{
#>
	<#=Utility.ToCamelLowerCase(method.Name)#>(<#=BuildMethodParameterList(method)#>): <#=method.ReturnType.TypeScriptTypeName#>{
<#+
		this.PushIndent(Constants.IndentString);
		this.PushIndent(Constants.IndentString);
		this.WritePlaceHolderContent(type.Name + "_" + method.Name, existingFileContent);
		this.PopIndent();
		this.PopIndent();

		var customCastIfAny = string.IsNullOrWhiteSpace(method.ReturnType.CustomTypeScriptTypeName) ? "" : "<" + method.ReturnType.CustomTypeScriptTypeName + "> ";
#>
		return <#= customCastIfAny #>new <#=method.ReturnType.TypeScriptTypeName#>(this.context, <#=Constants.MemberFullNames.CreateMethodObjectPath#>(this.context, this, "<#=method.Name#>", <#=Constants.TypeFullNames.OperationType#>.<#=method.OperationType#>, <#=BuildMethodParameterValueArray(method)#>, <#=Utility.GetBooleanLiteral(method.ReturnType.IsClientObjectCollection)#> /*isCollection*/, <#=Utility.GetBooleanLiteral(method.InvalidateReturnObjectPathAfterRequest)#> /*isInvalidAfterRequest*/, <#=method.ReturnObjectGetByIdMethodName == null ? "null" : "\"" + method.ReturnObjectGetByIdMethodName + "\""#> /*getByIdMethodName*/));
	}
<#+
	}
	
	private void WriteIndexerMethod(ClientCallableTypeInfo type, ClientCallableMethodInfo method, XDocument xdoc, string[] existingFileContent)
	{
#>
	<#=Utility.ToCamelLowerCase(method.Name)#>(<#=BuildMethodParameterList(method)#>): <#=method.ReturnType.TypeScriptTypeName#>{
<#+
		this.PushIndent(Constants.IndentString);
		this.PushIndent(Constants.IndentString);
		this.WritePlaceHolderContent(type.Name + "_" + method.Name, existingFileContent);
		this.PopIndent();
		this.PopIndent();
#>
		return new <#=method.ReturnType.TypeScriptTypeName#>(this.context, <#=Constants.MemberFullNames.CreateIndexerObjectPath#>(this.context, this, <#=BuildMethodParameterValueArray(method)#>));
	}
<#+
	}

	private void WriteEvents(ClientCallableTypeInfo type, XDocument xdoc, string[] existingFileContent)
	{
		foreach (ClientCallableEventInfo evt in type.Events)
		{
			this.WriteLine(string.Empty);
			this.PushIndent(Constants.IndentString);
			this.WriteComments(Utility.BuildJsDocForEvent(type, evt, xdoc));
			this.PopIndent();
#>
	get on<#=evt.Name#>(): <#=Constants.TypeFullNames.EventHandlers#>< <#=Utility.GetTypeScriptTypeName(evt.EventArgsType)#> >{
<#+
			this.PushIndent(Constants.IndentString);
			this.PushIndent(Constants.IndentString);
			this.WritePlaceHolderContent(type.Name + "_" + evt.Name + "_get", existingFileContent);
			this.PopIndent();
			this.PopIndent();
#>
		if (!this.m_<#=Utility.ToCamelLowerCase(evt.Name)#>){
<#+
			this.PushIndent(Constants.IndentString);
			this.PushIndent(Constants.IndentString);
			this.PushIndent(Constants.IndentString);
			this.WritePlaceHolderContent(type.Name + "_" + evt.Name + "_get_PreInit", existingFileContent);
			this.PopIndent();
			this.PopIndent();
			this.PopIndent();
#>
			this.m_<#=Utility.ToCamelLowerCase(evt.Name)#> = new <#=Constants.TypeFullNames.EventHandlers#>< <#=Utility.GetTypeScriptTypeName(evt.EventArgsType)#> >(
				this.context,
				this,
				"<#=evt.Name#>",
				// Please add eventInfo between the placeholders
<#+
			this.PushIndent(Constants.IndentString);
			this.PushIndent(Constants.IndentString);
			this.PushIndent(Constants.IndentString);
			this.PushIndent(Constants.IndentString);
			this.WritePlaceHolderContent(type.Name + "_" + evt.Name + "_Constructor_Parameters", existingFileContent);
			this.PopIndent();
			this.PopIndent();
			this.PopIndent();
			this.PopIndent();
#>
				);
<#+
			this.PushIndent(Constants.IndentString);
			this.PushIndent(Constants.IndentString);
			this.PushIndent(Constants.IndentString);
			this.WritePlaceHolderContent(type.Name + "_" + evt.Name + "_get_AfterInit", existingFileContent);
			this.PopIndent();
			this.PopIndent();
			this.PopIndent();
#>
		}
		return this.m_<#=Utility.ToCamelLowerCase(evt.Name)#>;
	}
<#+
		}
	}


	private void WriteNewObject(ClientCallableTypeInfo type)
	{
#>
	/** 
	 * Create a new instance of <#=type.ClientType.TypeScriptTypeName#> object
	 */
	static newObject(context: <#=Constants.TypeFullNames.ClientRequestContext#>): <#=type.ClientType.TypeScriptTypeName#> {
		var ret = new <#=type.ClientType.TypeScriptTypeName#>(context, <#=Constants.MemberFullNames.CreateNewObjectObjectPath#>(context, "<#=type.FullName#>", <#=Utility.GetBooleanLiteral(type.ClientType.IsClientObjectCollection)#> /*isCollection*/));
		return ret;
	} 
<#+
	}

	private string BuildMethodParameterList(ClientCallableMethodInfo method)
	{
		StringBuilder sb = new StringBuilder();
		for (int i = 0; i < method.Parameters.Count; i++)
		{
			ClientCallableParameterInfo param = method.Parameters[i];
			if (i != 0)
			{
				sb.Append(", ");
			}

			if (param.IsParams)
			{
				sb.Append("...");
			}

			sb.Append(param.Name);
			if (param.IsOptional)
			{
				sb.Append("?");
			}

			sb.Append(" : ");
			sb.Append(param.ParameterType.TypeScriptTypeName);
		}

		return sb.ToString();
	}

	private string BuildMethodParameterValueArray(ClientCallableMethodInfo method)
	{
		StringBuilder sb = new StringBuilder();
		sb.Append("[");
		for (int i = 0; i < method.Parameters.Count; i++)
		{
			if (i != 0)
			{
				sb.Append(", ");
			}

			sb.Append(method.Parameters[i].Name);
		}

		sb.Append("]");
		return sb.ToString();
	}

	private void WriteHandleResult(ClientCallableTypeInfo type)
	{
#>
	/** Handle results returned from the document
	 * @private
	 */
	_handleResult(value: any): void {
		super._handleResult(value);
		if (<#=Constants.MemberFullNames.IsNullOrUndefined#>(value))
			return;
		var obj: Object = value;
		<#=Constants.MemberFullNames.FixObjectPathIfNecessary#>(this, obj);
<#+
		foreach(ClientCallablePropertyInfo prop in type.ScalarProperties.Where(p => !p.ExcludedFromClientLibrary))
		{
#>
		if (!<#=Constants.MemberFullNames.IsUndefined#>(obj["<#=prop.Name#>"])){
<#+
			if (prop.PropertyType.IsDateTimeOrDateTimeArray)
			{
#>
			this.<#=prop.FieldName#> = <#=Constants.MemberFullNames.AdjustToDateTime#>(obj["<#=prop.Name#>"]);
<#+
			}
			else
			{
#>
			this.<#=prop.FieldName#> = obj["<#=prop.Name#>"];
<#+
			}
#>
		}

<#+
		}

		List<string> navPropNames = new List<string>();
		foreach (ClientCallablePropertyInfo prop in type.ObjectProperties.Where(p => !p.IsVolatile && !p.ExcludedFromClientLibrary))
		{
			navPropNames.Add("\"" + Utility.ToCamelLowerCase(prop.Name) + "\"");
			navPropNames.Add("\"" + prop.Name + "\"");
		}

		if (navPropNames.Count > 0)
		{
#>
		<#=Constants.MemberFullNames.HandleNavigationPropertyResults#>(this, obj, [<#=String.Join(", ", navPropNames.ToArray())#>]);
<#+	
		}

		if (type.ClientType.ChildItemClientType != null && type.ClientType.ChildItemClientType.IsClientObject)
		{
			bool hasIndexerMethod = (type.Methods.FirstOrDefault(m => m.IsIndexerMethod) != null);
#>
		if (!<#=Constants.MemberFullNames.IsNullOrUndefined#>(obj[OfficeExtension.Constants.items])){
			this.m__items = [];
			var _data: Array<any> = <Array<any>> obj[OfficeExtension.Constants.items];
			for (var i = 0; i < _data.length; i++)
			{
				var _item: <#=type.ClientType.ChildItemClientType.TypeScriptTypeName#> = new <#=type.ClientType.ChildItemClientType.TypeScriptTypeName#>(this.context, <#=Constants.MemberFullNames.CreateChildItemObjectPathUsingIndexerOrGetItemAt#>(<#=Utility.GetBooleanLiteral(hasIndexerMethod)#>, this.context, this, _data[i], i));
				_item._handleResult(_data[i]);
				this.m__items.push(_item);
			}
		}
<#+
		}
#>
	}
<#+
	}

	private void WriteHandleIdResultMethod(ClientCallableTypeInfo type)
	{
		if (!type.IsValueObject)
		{
			List<ClientCallablePropertyInfo> props = new List<ClientCallablePropertyInfo>();
			props.Add(type.ScalarProperties.FirstOrDefault(p => p.Name == Constants.MemberNames.ReferenceId));
			props.Add(type.ScalarProperties.FirstOrDefault(p => p.Name == Constants.MemberNames.Id));
			props.Add(type.ScalarProperties.FirstOrDefault(p => p.Name == Constants.MemberNames.IdPrivate));
			

			if (props.Any((prop) => prop != null && !prop.ExcludedFromClientLibrary))
			{
#>

	/** Handle identity results returned from the document
	 * @private
	 */
	_handleIdResult(value: any): void {
		super._handleIdResult(value);
		if (<#=Constants.MemberFullNames.IsNullOrUndefined#>(value)){
			return;
		}

<#+
				foreach(ClientCallablePropertyInfo prop in props)
				{
					if (prop != null && !prop.ExcludedFromClientLibrary)
					{
#>
		if (!<#=Constants.MemberFullNames.IsUndefined#>(value["<#=prop.Name#>"])){
			this.<#=prop.FieldName#> = value["<#=prop.Name#>"];
		}

<#+
					}
				}
#>

	}
<#+
			}
		}
	}

	private void WriteLoadMethod(ClientCallableTypeInfo type)
	{
		if (!type.IsValueObject)
		{
			// Only add a "load" method on objects that have properties or are collections.
			// Otherwise, for something like the Excel "Functions" object, since it's just a namespace placeholder object
			// with no actual properties on it, having "load" is only confusing.
			if (type.Properties.Any() || (type.ClientType.ChildItemClientType != null)) {
#>

	/**
	 * Queues up a command to load the specified properties of the object. You must call "context.sync()" before reading the properties.
	 */
	load(option?: string|string[]|OfficeExtension.LoadOption): <#= GetClientTypeOrCustomTypescriptName(type) #> {
		<#=Constants.MemberFullNames.Load#>(this, option);
		return this;
	}
<#+
			}
		}
	}

	private void WriteClientValueObjectType(ClientCallableTypeInfo type, XDocument xdoc, string[] existingFileContent)
	{
		// Skip over any intentionally-hidden or "V1" helper structs that are internal and are only meant to transfer data to/from V1.0 APIs
		if (type.Name.StartsWith("_", StringComparison.Ordinal) || type.Name.StartsWith("V1", StringComparison.Ordinal))
		{
			return;
		}
#>
export interface <#=type.Name#> {
<#+
		WriteClientValueObjectTypeFields(type, xdoc);
		this.WriteLine(string.Empty);
		this.PushIndent(Constants.IndentString);
		this.WritePlaceHolderContent(type.Name + "_Custom_Members", existingFileContent);
		this.PopIndent();
#>
}
<#+
	}

	private void WriteClientValueObjectTypeFields(ClientCallableTypeInfo type, XDocument xdoc)
	{
		foreach (ClientCallablePropertyInfo prop in type.Properties.Where(p => !p.ExcludedFromClientLibrary))
		{
			this.PushIndent(Constants.IndentString);
			this.WriteComments(Utility.BuildJsDocForProperty(type, prop, xdoc));
			this.PopIndent();
			string optional = "";
			if (prop.IsOptional)
			{
				optional = "?";
			}
#>
	<#=Utility.ToCamelLowerCase(prop.Name)#><#=optional#> : <#=prop.PropertyType.TypeScriptTypeName#>;
<#+
		}
	}

	private void WriteTrackUntrack(ClientCallableTypeInfo type)
	{
		if (!type.Methods.Where((method) => method.Name == "_KeepReference").Any())
		{
			return;
		}

#>

	/**
	 * Track the object for automatic adjustment based on surrounding changes in the document. This call is a shorthand for context.trackedObjects.add(thisObject). If you are using this object across ".sync" calls and outside the sequential execution of a ".run" batch, and get an "InvalidObjectPath" error when setting a property or invoking a method on the object, you needed to have added the object to the tracked object collection when the object was first created.
	 */
	track(): <#= GetClientTypeOrCustomTypescriptName(type) #> {
		this.context.trackedObjects.add(this);
		return this;
	}

	/**
	 * Release the memory associated with this object, if has previous been tracked. This call is shorthand for context.trackedObjects.remove(thisObject). Having many tracked objects slows down the host application, so please remember to free any objects you add, once you're done using them. You will need to call "context.sync()" before the memory release takes effect.
	 */
	untrack(): <#= GetClientTypeOrCustomTypescriptName(type) #> {
		this.context.trackedObjects.remove(this);
		return this;
	}
<#+
	}

	private string GetClientTypeOrCustomTypescriptName(ClientCallableTypeInfo type)
	{
		return string.IsNullOrEmpty(type.CustomTypeScriptTypeName) ? type.ClientType.TypeScriptTypeName : type.CustomTypeScriptTypeName;
	}

	private void WriteComments(IEnumerable<string> comments)
	{
		if (comments != null)
		{
			foreach (string line in comments)
			{
				this.WriteLine(line);
			}
		}
	}
#>
