<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Xml" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="Helper.tt" #>
<#@ include file="Core.tt" #>
<#@ output extension=".txt" #>
<#+
	void WriteTypeScript()
	{
		this.LaunchDebuggerIfNecessary();
		if (this.CheckInputParameters())
		{
			CodeGenTemplateFileManager templateFileManager = new CodeGenTemplateFileManager(this.GenerationEnvironment);
			templateFileManager.StartHeader();

#>
/*
 * This is a generated file. <#=this.CreatedByToolStatement#>
 * If there are content placeholders, only edit content inside content placeholders.
 * If there are no content placeholders, do not edit this file directly.
 */

<#+
			templateFileManager.EndBlock();

			templateFileManager.StartNewFile(this.FileBaseName + ".ts");
			this.WriteTypeScriptBody(System.IO.Path.Combine(this.OutputDirectory, this.FileBaseName + ".ts"));
			templateFileManager.EndBlock();
			
			templateFileManager.WriteTo(this.OutputDirectory, this.CheckoutCommandPrefix);
		}
	}

	void WriteTypeScriptBody(string existingFilePath)
	{
		string[] existingFileContent = new string[0];
		if (File.Exists(existingFilePath))
		{
			existingFileContent = File.ReadAllLines(existingFilePath);
		}

		this.WriteLine(string.Empty);
		this.WritePlaceHolderContent("GlobalHeader", existingFileContent);
		this.WriteLine(string.Empty);

		XDocument xdoc;
		if (string.IsNullOrWhiteSpace(this.DocXmlFilePath))
		{
			xdoc = new XDocument();
		}
		else
		{
			xdoc = XDocument.Load(this.DocXmlFilePath);
		}

		AssemblyReader assemblyReader = new AssemblyReader(this.InputFilePath, null, this.ReferencedAssemblyPaths);
		assemblyReader.Process();
		List<string> namespaceStack = new List<string>();
		bool first = true;
		foreach (ClientCallableTypeInfo type in assemblyReader.Types)
		{
			this.EnsureNamespace(namespaceStack, type.TypescriptNamespace, forTypeScript: true, indentString: Constants.IndentString);
			if (first)
			{
				this.WritePlaceHolderContent("ModuleHeader", existingFileContent);
				this.WriteMethodAlias();
				first = false;
			}
			this.WriteLine(string.Empty);
			WriteType(type, xdoc, existingFileContent);
		}

		WriteErrorCode(assemblyReader.AllErrorCodes);

		this.EnsureNamespace(namespaceStack, string.Empty, forTypeScript: true, indentString: Constants.IndentString);
		this.WriteLine(string.Empty);
		this.WritePlaceHolderContent("GlobalFooter", existingFileContent);
		this.WriteLine(string.Empty);
		WriteStatistics(assemblyReader);
	}

	private void WriteMethodAlias()
	{
#>

var _createPropertyObjectPath = OfficeExtension.ObjectPathFactory.createPropertyObjectPath;
var _createMethodObjectPath = OfficeExtension.ObjectPathFactory.createMethodObjectPath;
var _createIndexerObjectPath = OfficeExtension.ObjectPathFactory.createIndexerObjectPath;
var _createNewObjectObjectPath = OfficeExtension.ObjectPathFactory.createNewObjectObjectPath;
var _createChildItemObjectPathUsingIndexer = OfficeExtension.ObjectPathFactory.createChildItemObjectPathUsingIndexer;
var _createChildItemObjectPathUsingGetItemAt = OfficeExtension.ObjectPathFactory.createChildItemObjectPathUsingGetItemAt;
var _createChildItemObjectPathUsingIndexerOrGetItemAt = OfficeExtension.ObjectPathFactory.createChildItemObjectPathUsingIndexerOrGetItemAt;
var _createMethodAction = OfficeExtension.ActionFactory.createMethodAction;
var _createSetPropertyAction = OfficeExtension.ActionFactory.createSetPropertyAction;
var _isNullOrUndefined = OfficeExtension.Utility.isNullOrUndefined;
var _isUndefined = OfficeExtension.Utility.isUndefined;
var _throwIfNotLoaded = OfficeExtension.Utility.throwIfNotLoaded;
var _load = OfficeExtension.Utility.load;
var _fixObjectPathIfNecessary = OfficeExtension.Utility.fixObjectPathIfNecessary;
var _addActionResultHandler = OfficeExtension.Utility._addActionResultHandler;
var _handleNavigationPropertyResults = OfficeExtension.Utility._handleNavigationPropertyResults;
<#+
	}

	private void WriteStatistics(AssemblyReader assemblyReader)
	{
		Console.WriteLine();
		Console.WriteLine("---Statistics Begin---");
		int typeCount = 0;
		int propertyGetCount = 0;
		int propertySetCount = 0;
		int methodCount = 0;

		foreach (ClientCallableTypeInfo type in assemblyReader.Types)
		{
			typeCount++;
			propertyGetCount += type.Properties.Count;
			propertySetCount += type.Properties.Where(p => p.IsReadonly).Count();
			methodCount += type.Methods.Count;
		}

		Console.WriteLine("Types={0}", typeCount);
		Console.WriteLine("Property Getter={0}", propertyGetCount);
		Console.WriteLine("Property Setter={0}", propertySetCount);
		Console.WriteLine("Methods={0}", methodCount);
		Console.WriteLine("---Statistics End---");
		Console.WriteLine();
	}
#>

<#+
	private void WriteErrorCode(IEnumerable<string> errorCodes)
	{
#>

export module ErrorCodes
{
<#+
		foreach(string errorCode in errorCodes.OrderBy(s => s))
		{
#>
	export var <#=Utility.ToCamelLowerCase(errorCode)#>: string = "<#=errorCode#>";
<#+
		}
#>
}

<#+
	}

	private void WriteType(ClientCallableTypeInfo type, XDocument xdoc, string[] existingFileContent)
	{
		this.WriteComments(Utility.BuildJsDocForType(type, xdoc));
		if (type.IsEnum)
		{
			WriteEnumType(type, xdoc);
		}
		else if (type.IsValueObject)
		{
			WriteClientValueObjectType(type, xdoc, existingFileContent);
		}
		else
		{
			WriteClientObjectType(type, xdoc, existingFileContent);
		}
	}

	private void WriteEnumType(ClientCallableTypeInfo type, XDocument xdoc)
	{
#>
export module <#=type.Name#>
{
<#+
		foreach (KeyValuePair<string, int> field in type.EnumFields)
		{
			this.WriteLine(string.Empty);
			this.PushIndent(Constants.IndentString);
			this.WriteComments(Utility.BuildJsDocForEnumField(type, field.Key, xdoc));
			this.PopIndent();
#>
	export var <#=Utility.ToCamelLowerCase(field.Key)#> : string = "<#=Utility.TrimUnderscore(field.Key)#>";
<#+
		}
#>
}
<#+
	}

	private void WriteClientObjectType(ClientCallableTypeInfo type, XDocument xdoc, string[] existingFileContent)
	{
		string typeNameOrCustom = string.IsNullOrEmpty(type.CustomTypeScriptTypeName) ? type.Name : type.CustomTypeScriptTypeName;
#>
export class <#= typeNameOrCustom #> extends <#=Constants.TypeFullNames.ClientObject#> {
<#+
		WriteTypeFields(type);
		this.WriteLine(string.Empty);
		this.PushIndent(Constants.IndentString);
		this.WritePlaceHolderContent(type.Name + "_Custom_Members", existingFileContent);
		this.PopIndent();
		WriteObjectProperties(type, xdoc);
		WriteScalarProperties(type, xdoc);
		WriteMethods(type, xdoc, existingFileContent);
		this.WriteLine(string.Empty);
		WriteHandleResult(type);
		WriteLoadMethod(type);
		WriteInitReferenceIdMethod(type);
		if (type.AllowCreation)
		{
			this.WriteLine(string.Empty);
			WriteNewObject(type);
		}
#>
}
<#+ 
	}

	private void WriteTypeFields(ClientCallableTypeInfo type)
	{
		foreach (ClientCallablePropertyInfo prop in type.Properties.Where(p => !p.IsVolatile && !p.ExcludedFromClientLibrary))
		{
#>
	private m_<#=Utility.ToCamelLowerCase(prop.Name)#> : <#=prop.PropertyType.TypeScriptTypeName#>;
<#+
		}

		if (type.ClientType.ChildItemClientType != null && type.ClientType.ChildItemClientType.IsClientObject)
		{
#>
	private m__items: Array< <#=type.ClientType.ChildItemClientType.TypeScriptTypeName#> >;
<#+
		}
	}

	private void WriteObjectProperties(ClientCallableTypeInfo type, XDocument xdoc)
	{
		foreach (ClientCallablePropertyInfo prop in type.ObjectProperties.Where(p => !p.IsVolatile && !p.ExcludedFromClientLibrary))
		{
			this.PushIndent(Constants.IndentString);
			this.WriteComments(Utility.BuildJsDocForProperty(type, prop, xdoc));
			this.PopIndent();
#>

	get <#=Utility.ToCamelLowerCase(prop.Name)#>(): <#=prop.PropertyType.TypeScriptTypeName#>{
		if (!this.<#=prop.FieldName#>){
			this.<#=prop.FieldName#> = new <#=prop.PropertyType.TypeScriptTypeName#>(this.context, <#=Constants.MemberFullNames.CreatePropertyObjectPath#>(this.context, this, "<#=prop.Name#>", <#=Utility.GetBooleanLiteral(prop.PropertyType.IsClientObjectCollection)#> /*isCollection*/, false /*isInvalidAfterRequest*/));
		}
		return this.<#=prop.FieldName#>;
	}
<#+
			if (!prop.IsReadonly)
			{
				// NOTE: Do *NOT* write JSDOC comments on setters. Doing so creates a doubled-up comment on the property in the final TypeScript / d.ts file.
				// Just writing the JSDOC comment on the getter is perfectly sufficient (and our underlying assumption is that there are
				// no such things as write-only properties -- that same assumption is already used above, when creating the getter).
#>

	set <#=Utility.ToCamelLowerCase(prop.Name)#>(value: <#=prop.PropertyType.TypeScriptTypeName#>){
		this.<#=prop.FieldName#> = value;
		<#=Constants.MemberFullNames.CreateSetPropertyAction#>(this.context, this, "<#=prop.Name#>", value);
	}
<#+	
			}
		}

		foreach (ClientCallablePropertyInfo prop in type.ObjectProperties.Where(p => p.IsVolatile && !p.ExcludedFromClientLibrary))
		{
			this.WriteLine(string.Empty);
			this.PushIndent(Constants.IndentString);
			this.WriteComments(Utility.BuildJsDocForProperty(type, prop, xdoc));
			this.PopIndent();
#>
	get<#=Utility.ToCamelUpperCase(prop.Name)#>(): <#=prop.PropertyType.TypeScriptTypeName#>{
		return new <#=prop.PropertyType.TypeScriptTypeName#>(this.context, <#=Constants.MemberFullNames.CreatePropertyObjectPath#>(this.context, this, "<#=prop.Name#>", <#=Utility.GetBooleanLiteral(prop.PropertyType.IsClientObjectCollection)#> /*isCollection*/, <#=Utility.GetBooleanLiteral(prop.InvalidateReturnObjectPathAfterRequest)#> /*isInvalidAfterRequest*/));
	}
<#+
			if (!prop.IsReadonly)
			{
				this.WriteLine(string.Empty);
				// NOTE: Do *NOT* write JSDOC comments on setters. Doing so creates a doubled-up comment on the property in the final TypeScript / d.ts file.
				// Just writing the JSDOC comment on the getter is perfectly sufficient (and our underlying assumption is that there are
				// no such things as write-only properties -- that same assumption is already used above, when creating the getter).
#>
	set<#=Utility.ToCamelUpperCase(prop.Name)#>(value: <#=prop.PropertyType.TypeScriptTypeName#>){
		<#=Constants.MemberFullNames.CreateSetPropertyAction#>(this.context, this, "<#=prop.Name#>", value);
	}
<#+
			}
		}

		// child items
		if (type.ClientType.ChildItemClientType != null && type.ClientType.ChildItemClientType.IsClientObject)
		{
#>

	/** Gets the loaded child items in this collection. */
	get items(): Array< <#=type.ClientType.ChildItemClientType.TypeScriptTypeName#> > {
		<#=Constants.MemberFullNames.ThrowIfNotLoaded#>("items", this.m__items);
		return this.m__items;
	}
<#+
		}
	}

	private void WriteScalarProperties(ClientCallableTypeInfo type, XDocument xdoc)
	{
		foreach (ClientCallablePropertyInfo prop in type.ScalarProperties.Where(p => !p.ExcludedFromClientLibrary))
		{
			this.WriteLine(string.Empty);
			this.PushIndent(Constants.IndentString);
			this.WriteComments(Utility.BuildJsDocForProperty(type, prop, xdoc));
			this.PopIndent();
#>
	get <#=Utility.ToCamelLowerCase(prop.Name)#>(): <#=prop.PropertyType.TypeScriptTypeName#>{
		<#=Constants.MemberFullNames.ThrowIfNotLoaded#>("<#=Utility.ToCamelLowerCase(prop.Name)#>", this.<#=prop.FieldName#>);
		return this.<#=prop.FieldName#>;
	}
<#+
			if (!prop.IsReadonly)
			{
				this.WriteLine(string.Empty);
				// NOTE: Do *NOT* write JSDOC comments on setters. Doing so creates a doubled-up comment on the property in the final TypeScript / d.ts file.
				// Just writing the JSDOC comment on the getter is perfectly sufficient (and our underlying assumption is that there are
				// no such things as write-only properties -- that same assumption is already used above, when creating the getter).
#>
	set <#=Utility.ToCamelLowerCase(prop.Name)#>(value: <#=prop.PropertyType.TypeScriptTypeName#>){
		this.<#=prop.FieldName#> = value;
		<#=Constants.MemberFullNames.CreateSetPropertyAction#>(this.context, this, "<#=prop.Name#>", value);
	}
<#+	
			}
		}
	}

	private void WriteMethods(ClientCallableTypeInfo type, XDocument xdoc, string[] existingFileContent)
	{
		foreach (ClientCallableMethodInfo method in type.Methods.Where(m => m.ShouldGenerateScriptMethod))
		{
			this.WriteLine(string.Empty);
			this.PushIndent(Constants.IndentString);
			this.WriteComments(Utility.BuildJsDocForMethod(type, method, xdoc));
			this.PopIndent();
			if (method.ReturnType.IsClientObject)
			{
				if (method.IsIndexerMethod)
				{
					WriteIndexerMethod(type, method, xdoc, existingFileContent);
				}
				else
				{
					WriteObjectMethod(type, method, xdoc, existingFileContent);
				}
			}
			else
			{
				if (method.ReturnType.IsVoid)
				{
					WriteScalarMethodReturnVoid(type, method, xdoc, existingFileContent);
				}
				else
				{
					WriteScalarMethodReturnValue(type, method, xdoc, existingFileContent);
				}
			}
		}
	}

	private void WriteScalarMethodReturnVoid(ClientCallableTypeInfo type, ClientCallableMethodInfo method, XDocument xdoc, string[] existingFileContent)
	{
#>
	<#=Utility.ToCamelLowerCase(method.Name)#>(<#=BuildMethodParameterList(method)#>): void {
<#+
		this.PushIndent(Constants.IndentString);
		this.PushIndent(Constants.IndentString);
		this.WritePlaceHolderContent(type.Name + "_" + method.Name, existingFileContent);
		this.PopIndent();
		this.PopIndent();
#>
		<#=Constants.MemberFullNames.CreateMethodAction#>(this.context, this, "<#=method.Name#>", <#=Constants.TypeFullNames.OperationType#>.<#=method.OperationType#>, <#=BuildMethodParameterValueArray(method)#>);
	}
<#+
	}

	private void WriteScalarMethodReturnValue(ClientCallableTypeInfo type, ClientCallableMethodInfo method, XDocument xdoc, string[] existingFileContent)
	{
#>
	<#=Utility.ToCamelLowerCase(method.Name)#>(<#=BuildMethodParameterList(method)#>): <#=Constants.TypeFullNames.ClientResultGenericPrefix#> <#=method.ReturnType.TypeScriptTypeName#> <#=Constants.TypeFullNames.ClientResultGenericSuffix#>{
<#+
		this.PushIndent(Constants.IndentString);
		this.PushIndent(Constants.IndentString);
		this.WritePlaceHolderContent(type.Name + "_" + method.Name, existingFileContent);
		this.PopIndent();
		this.PopIndent();
#>
		var action = <#=Constants.MemberFullNames.CreateMethodAction#>(this.context, this, "<#=method.Name#>", <#=Constants.TypeFullNames.OperationType#>.<#=method.OperationType#>, <#=BuildMethodParameterValueArray(method)#>);
		var ret = new <#=Constants.TypeFullNames.ClientResultGenericPrefix#> <#=method.ReturnType.TypeScriptTypeName#> <#=Constants.TypeFullNames.ClientResultGenericSuffix#>();
		<#=Constants.MemberFullNames.AddActionResultHandler#>(this, action, ret);
		return ret;
	}
<#+
	}

	private void WriteObjectMethod(ClientCallableTypeInfo type, ClientCallableMethodInfo method, XDocument xdoc, string[] existingFileContent)
	{
#>
	<#=Utility.ToCamelLowerCase(method.Name)#>(<#=BuildMethodParameterList(method)#>): <#=method.ReturnType.TypeScriptTypeName#>{
<#+
		this.PushIndent(Constants.IndentString);
		this.PushIndent(Constants.IndentString);
		this.WritePlaceHolderContent(type.Name + "_" + method.Name, existingFileContent);
		this.PopIndent();
		this.PopIndent();

		var customCastIfAny = string.IsNullOrWhiteSpace(method.ReturnType.CustomTypeScriptTypeName) ? "" : "<" + method.ReturnType.CustomTypeScriptTypeName + "> ";
#>
		return <#= customCastIfAny #>new <#=method.ReturnType.TypeScriptTypeName#>(this.context, <#=Constants.MemberFullNames.CreateMethodObjectPath#>(this.context, this, "<#=method.Name#>", <#=Constants.TypeFullNames.OperationType#>.<#=method.OperationType#>, <#=BuildMethodParameterValueArray(method)#>, <#=Utility.GetBooleanLiteral(method.ReturnType.IsClientObjectCollection)#> /*isCollection*/, <#=Utility.GetBooleanLiteral(method.InvalidateReturnObjectPathAfterRequest)#> /*isInvalidAfterRequest*/));
	}
<#+
	}
	
	private void WriteIndexerMethod(ClientCallableTypeInfo type, ClientCallableMethodInfo method, XDocument xdoc, string[] existingFileContent)
	{
#>
	<#=Utility.ToCamelLowerCase(method.Name)#>(<#=BuildMethodParameterList(method)#>): <#=method.ReturnType.TypeScriptTypeName#>{
<#+
		this.PushIndent(Constants.IndentString);
		this.PushIndent(Constants.IndentString);
		this.WritePlaceHolderContent(type.Name + "_" + method.Name, existingFileContent);
		this.PopIndent();
		this.PopIndent();
#>
		return new <#=method.ReturnType.TypeScriptTypeName#>(this.context, <#=Constants.MemberFullNames.CreateIndexerObjectPath#>(this.context, this, <#=BuildMethodParameterValueArray(method)#>));
	}
<#+
	}

	private void WriteNewObject(ClientCallableTypeInfo type)
	{
#>
	/** 
	 * Create a new instance of <#=type.ClientType.TypeScriptTypeName#> object
	 */
	static newObject(context: <#=Constants.TypeFullNames.ClientRequestContext#>): <#=type.ClientType.TypeScriptTypeName#> {
		var ret = new <#=type.ClientType.TypeScriptTypeName#>(context, <#=Constants.MemberFullNames.CreateNewObjectObjectPath#>(context, "<#=type.FullName#>", <#=Utility.GetBooleanLiteral(type.ClientType.IsClientObjectCollection)#> /*isCollection*/));
		return ret;
	} 
<#+
	}

	private string BuildMethodParameterList(ClientCallableMethodInfo method)
	{
		StringBuilder sb = new StringBuilder();
		for (int i = 0; i < method.Parameters.Count; i++)
		{
			ClientCallableParameterInfo param = method.Parameters[i];
			if (i != 0)
			{
				sb.Append(", ");
			}

			if (param.IsParams)
			{
				sb.Append("...");
			}

			sb.Append(param.Name);
			if (param.IsOptional)
			{
				sb.Append("?");
			}

			sb.Append(" : ");
			sb.Append(param.ParameterType.TypeScriptTypeName);
		}

		return sb.ToString();
	}

	private string BuildMethodParameterValueArray(ClientCallableMethodInfo method)
	{
		StringBuilder sb = new StringBuilder();
		sb.Append("[");
		for (int i = 0; i < method.Parameters.Count; i++)
		{
			if (i != 0)
			{
				sb.Append(", ");
			}

			sb.Append(method.Parameters[i].Name);
		}

		sb.Append("]");
		return sb.ToString();
	}

	private void WriteHandleResult(ClientCallableTypeInfo type)
	{
#>
	/** Handle results returned from the document
	 * @private
	 */
	_handleResult(value: any): void {
		if (<#=Constants.MemberFullNames.IsNullOrUndefined#>(value))
			return;
		var obj: Object = value;
		<#=Constants.MemberFullNames.FixObjectPathIfNecessary#>(this, obj);
<#+
		foreach(ClientCallablePropertyInfo prop in type.ScalarProperties.Where(p => !p.ExcludedFromClientLibrary))
		{
#>
		if (!<#=Constants.MemberFullNames.IsUndefined#>(obj["<#=prop.Name#>"])){
			this.<#=prop.FieldName#> = obj["<#=prop.Name#>"];
		}

<#+
		}

		List<string> navPropNames = new List<string>();
		foreach (ClientCallablePropertyInfo prop in type.ObjectProperties.Where(p => !p.IsVolatile && !p.ExcludedFromClientLibrary))
		{
			navPropNames.Add("\"" + Utility.ToCamelLowerCase(prop.Name) + "\"");
			navPropNames.Add("\"" + prop.Name + "\"");
		}

		if (navPropNames.Count > 0)
		{
#>
		<#=Constants.MemberFullNames.HandleNavigationPropertyResults#>(this, obj, [<#=String.Join(", ", navPropNames.ToArray())#>]);
<#+	
		}

		if (type.ClientType.ChildItemClientType != null && type.ClientType.ChildItemClientType.IsClientObject)
		{
			bool hasIndexerMethod = (type.Methods.FirstOrDefault(m => m.IsIndexerMethod) != null);
#>
		if (!<#=Constants.MemberFullNames.IsNullOrUndefined#>(obj[OfficeExtension.Constants.items])){
			this.m__items = [];
			var _data: Array<any> = <Array<any>> obj[OfficeExtension.Constants.items];
			for (var i = 0; i < _data.length; i++)
			{
				var _item: <#=type.ClientType.ChildItemClientType.TypeScriptTypeName#> = new <#=type.ClientType.ChildItemClientType.TypeScriptTypeName#>(this.context, <#=Constants.MemberFullNames.CreateChildItemObjectPathUsingIndexerOrGetItemAt#>(<#=Utility.GetBooleanLiteral(hasIndexerMethod)#>, this.context, this, _data[i], i));
				_item._handleResult(_data[i]);
				this.m__items.push(_item);
			}
		}
<#+
		}
#>
	}
<#+
	}

	private void WriteInitReferenceIdMethod(ClientCallableTypeInfo type)
	{
		ClientCallablePropertyInfo prop = type.ScalarProperties.FirstOrDefault(p => p.Name == Constants.MemberNames.ReferenceId);
		if (!type.IsValueObject && prop != null)
		{
#>
	_initReferenceId(value: string): void {
		this.<#=prop.FieldName#> = value;
	}
<#+
		}
	}

	private void WriteLoadMethod(ClientCallableTypeInfo type)
	{
		if (!type.IsValueObject)
		{
			// Only add a "load" method on objects that have properties or are collections.
			// Otherwise, for something like the Excel "Functions" object, since it's just a namespace placeholder object
			// with no actual properties on it, having "load" is only confusing.
			if (type.Properties.Any() || (type.ClientType.ChildItemClientType != null)) {
				var clientTypeOrCustomTypescriptName = string.IsNullOrEmpty(type.CustomTypeScriptTypeName) ? type.ClientType.TypeScriptTypeName : type.CustomTypeScriptTypeName;
#>

	/**
	 * Queues up a command to load the specified properties of the object. You must call "context.sync()" before reading the properties.
	 */
	load(option?: string|string[]|OfficeExtension.LoadOption): <#= clientTypeOrCustomTypescriptName #> {
		<#=Constants.MemberFullNames.Load#>(this, option);
		return this;
	}
<#+
			}
		}
	}

	private void WriteClientValueObjectType(ClientCallableTypeInfo type, XDocument xdoc, string[] existingFileContent)
	{
#>
export interface <#=type.Name#> {
<#+
		WriteClientValueObjectTypeFields(type, xdoc);
		this.WriteLine(string.Empty);
		this.PushIndent(Constants.IndentString);
		this.WritePlaceHolderContent(type.Name + "_Custom_Members", existingFileContent);
		this.PopIndent();
#>
}
<#+
	}

	private void WriteClientValueObjectTypeFields(ClientCallableTypeInfo type, XDocument xdoc)
	{
		foreach (ClientCallablePropertyInfo prop in type.Properties.Where(p => !p.ExcludedFromClientLibrary))
		{
			this.PushIndent(Constants.IndentString);
			this.WriteComments(Utility.BuildJsDocForProperty(type, prop, xdoc));
			this.PopIndent();
			string optional = "";
			if (prop.IsOptional)
			{
				optional = "?";
			}
#>
	<#=Utility.ToCamelLowerCase(prop.Name)#><#=optional#> : <#=prop.PropertyType.TypeScriptTypeName#>;
<#+
		}
	}

	private void WriteComments(IEnumerable<string> comments)
	{
		if (comments != null)
		{
			foreach (string line in comments)
			{
				this.WriteLine(line);
			}
		}
	}
#>
