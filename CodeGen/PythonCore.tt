<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Xml" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="Helper.tt" #>
<#@ include file="Core.tt" #>
<#@ output extension=".txt" #>
<#+
	void WritePython()
	{
		this.LaunchDebuggerIfNecessary();
		if (this.CheckInputParameters())
		{
			this.UsePoundCommentStyle = true;
			CodeGenTemplateFileManager templateFileManager = new CodeGenTemplateFileManager(this.GenerationEnvironment);
			templateFileManager.StartHeader();

#>
#
# This is a generated file. <#=this.CreatedByToolStatement#>
# If there are content placeholders, only edit content inside content placeholders.
# If there are no content placeholders, do not edit this file directly.
#

<#+
			templateFileManager.EndBlock();

			templateFileManager.StartNewFile(this.FileBaseName.ToLowerInvariant() + ".py");
			this.WritePythonBody(System.IO.Path.Combine(this.OutputDirectory, this.FileBaseName + ".py"));
			templateFileManager.EndBlock();
			
			templateFileManager.WriteTo(this.OutputDirectory, this.CheckoutCommandPrefix);
		}
	}

	void WritePythonBody(string existingFilePath)
	{
		string[] existingFileContent = new string[0];
		if (File.Exists(existingFilePath))
		{
			existingFileContent = File.ReadAllLines(existingFilePath);
		}
#>
import sys
import json
import enum
import logging
<#+
		this.WriteLine(string.Empty);
		this.WritePlaceHolderContent("GlobalHeader", existingFileContent);
		this.WriteLine(string.Empty);

		this.WriteMethodAlias();

		XDocument xdoc;
		if (string.IsNullOrWhiteSpace(this.DocXmlFilePath))
		{
			xdoc = new XDocument();
		}
		else
		{
			xdoc = XDocument.Load(this.DocXmlFilePath);
		}

		AssemblyReader assemblyReader = new AssemblyReader(this.InputFilePath, null, this.ReferencedAssemblyPaths);
		assemblyReader.Process();
		List<string> namespaceStack = new List<string>();
		foreach (ClientCallableTypeInfo type in assemblyReader.Types)
		{
			this.WriteLine(string.Empty);
			WriteType(type, xdoc, existingFileContent);
		}

		this.WriteLine(string.Empty);
		this.WritePlaceHolderContent("GlobalFooter", existingFileContent);
		this.WriteLine(string.Empty);
	}

	private void WriteMethodAlias()
	{
#>
_createPropertyObjectPath = OfficeExtension.ObjectPathFactory.createPropertyObjectPath;
_createMethodObjectPath = OfficeExtension.ObjectPathFactory.createMethodObjectPath;
_createIndexerObjectPath = OfficeExtension.ObjectPathFactory.createIndexerObjectPath;
_createNewObjectObjectPath = OfficeExtension.ObjectPathFactory.createNewObjectObjectPath;
_createChildItemObjectPathUsingIndexer = OfficeExtension.ObjectPathFactory.createChildItemObjectPathUsingIndexer;
_createChildItemObjectPathUsingGetItemAt = OfficeExtension.ObjectPathFactory.createChildItemObjectPathUsingGetItemAt;
_createChildItemObjectPathUsingIndexerOrGetItemAt = OfficeExtension.ObjectPathFactory.createChildItemObjectPathUsingIndexerOrGetItemAt;
_createMethodAction = OfficeExtension.ActionFactory.createMethodAction;
_createSetPropertyAction = OfficeExtension.ActionFactory.createSetPropertyAction;
_isNullOrUndefined = OfficeExtension.Utility.isNullOrUndefined;
_isUndefined = OfficeExtension.Utility.isUndefined;
_throwIfNotLoaded = OfficeExtension.Utility.throwIfNotLoaded;
_load = OfficeExtension.Utility.load;
_fixObjectPathIfNecessary = OfficeExtension.Utility.fixObjectPathIfNecessary;
_addActionResultHandler = OfficeExtension.Utility._addActionResultHandler;
<#+
	}

	private void WriteErrorCode(IEnumerable<string> errorCodes)
	{
#>

class ErrorCodes:
{
<#+
		this.PushIndent(Constants.IndentSpaceString);
		foreach(string errorCode in errorCodes.OrderBy(s => s))
		{
#>
<#=Utility.ToCamelLowerCase(errorCode)#>= "<#=errorCode#>"
<#+
		}
		this.PopIndent();
#>
}

<#+
	}

	private void WriteType(ClientCallableTypeInfo type, XDocument xdoc, string[] existingFileContent)
	{
		if (type.IsEnum)
		{
			WriteEnumType(type, xdoc);
		}
		else if (type.IsValueObject)
		{
			WriteClientValueObjectType(type, xdoc, existingFileContent);
		}
		else
		{
			WriteClientObjectType(type, xdoc, existingFileContent);
		}
	}

	private string NormalizeMemberName(string name)
	{
		string[] keywords = new string[] 
			{
				"and",
				"or",
				"lambda",
				"if",
				"not",
				"yield",
			};

		if (keywords.Contains(name))
		{
			return  name + "_";
		}

		return name;
	}

	private void WriteEnumType(ClientCallableTypeInfo type, XDocument xdoc)
	{
#>
class <#=type.Name#>:
<#+
		this.PushIndent(Constants.IndentSpaceString);
		foreach (KeyValuePair<string, int> field in type.EnumFields)
		{
#>
<#=NormalizeMemberName(Utility.ToCamelLowerCase(field.Key))#> = "<#=Utility.TrimUnderscore(field.Key)#>"
<#+
		}
		this.PopIndent();
	}

	private void WriteClientObjectType(ClientCallableTypeInfo type, XDocument xdoc, string[] existingFileContent)
	{
		string typeNameOrCustom = string.IsNullOrEmpty(type.CustomTypeScriptTypeName) ? type.Name : type.CustomTypeScriptTypeName;
#>
class <#= type.Name #>(<#=Constants.TypeFullNames.ClientObject#>):
<#+
		this.PushIndent(Constants.IndentSpaceString);
		this.WritePlaceHolderContent(type.Name + "_Custom_Members", existingFileContent);
		WriteConstructor(type);
		this.WriteLine(string.Empty);
		WriteObjectProperties(type, xdoc);
		WriteScalarProperties(type, xdoc);
		WriteMethods(type, xdoc, existingFileContent);
		this.WriteLine(string.Empty);
		WriteHandleResult(type);
		WriteLoadMethod(type);
		WriteInitReferenceIdMethod(type);
		if (type.AllowCreation)
		{
			this.WriteLine(string.Empty);
			WriteNewObject(type);
		}
		this.PopIndent();
	}

	private void WriteConstructor(ClientCallableTypeInfo type)
	{
#>
def __init__(self, context: <#=Constants.TypeFullNames.ClientRequestContext#>, objectPath: <#= Constants.TypeFullNames.ObjectPath #>):
<#+
		this.PushIndent(Constants.IndentSpaceString);
#>
super(self.__class__, self).__init__(context, objectPath)
<#+
		foreach (ClientCallablePropertyInfo prop in type.Properties.Where(p => !p.IsVolatile && !p.ExcludedFromClientLibrary))
		{
#>
self._<#=Utility.ToCamelLowerCase(prop.Name)#> = None
<#+
		}

		if (type.ClientType.ChildItemClientType != null && type.ClientType.ChildItemClientType.IsClientObject)
		{
#>
self.__items = None
<#+
		}

		this.PopIndent();
	}

	private void WriteObjectProperties(ClientCallableTypeInfo type, XDocument xdoc)
	{
		foreach (ClientCallablePropertyInfo prop in type.ObjectProperties.Where(p => !p.IsVolatile && !p.ExcludedFromClientLibrary))
		{
#>
@property
def <#=NormalizeMemberName(Utility.ToCamelLowerCase(prop.Name))#>(self) -> '<#=prop.PropertyType.PythonTypeName#>':
    if self.<#=prop.PythonFieldName#> is None:
        self.<#=prop.PythonFieldName#> = <#=prop.PropertyType.PythonTypeName#>(self.context, <#=Constants.MemberFullNames.CreatePropertyObjectPath#>(self.context, self, "<#=prop.Name#>", <#=Utility.GetPythonBooleanLiteral(prop.PropertyType.IsClientObjectCollection)#>, False))
    return self.<#=prop.PythonFieldName#>
<#+
			if (!prop.IsReadonly)
			{
#>

@<#=Utility.ToCamelLowerCase(prop.Name)#>.setter
def <#=NormalizeMemberName(Utility.ToCamelLowerCase(prop.Name))#>(self, value: '<#=prop.PropertyType.PythonTypeName#>') -> None:
    self.<#=prop.PythonFieldName#> = value
    <#=Constants.MemberFullNames.CreateSetPropertyAction#>(self.context, self, "<#=prop.Name#>", value);
<#+	
			}
		}

		foreach (ClientCallablePropertyInfo prop in type.ObjectProperties.Where(p => p.IsVolatile && !p.ExcludedFromClientLibrary))
		{
			this.WriteLine(string.Empty);
#>
def get<#=Utility.ToCamelUpperCase(prop.Name)#>(self) -> '<#=prop.PropertyType.PythonTypeName#>':
    return <#=prop.PropertyType.PythonTypeName#>(self.context, <#=Constants.MemberFullNames.CreatePropertyObjectPath#>(self.context, self, "<#=prop.Name#>", <#=Utility.GetPythonBooleanLiteral(prop.PropertyType.IsClientObjectCollection)#>, <#=Utility.GetPythonBooleanLiteral(prop.InvalidateReturnObjectPathAfterRequest)#>))
<#+
			if (!prop.IsReadonly)
			{
				this.WriteLine(string.Empty);
				// NOTE: Do *NOT* write JSDOC comments on setters. Doing so creates a doubled-up comment on the property in the final TypeScript / d.ts file.
				// Just writing the JSDOC comment on the getter is perfectly sufficient (and our underlying assumption is that there are
				// no such things as write-only properties -- that same assumption is already used above, when creating the getter).
#>
def set<#=Utility.ToCamelUpperCase(prop.Name)#>(self, value -> '<#=prop.PropertyType.PythonTypeName#>') -> None:
    <#=Constants.MemberFullNames.CreateSetPropertyAction#>(self.context, self, "<#=prop.Name#>", value)
<#+
			}
		}

		// child items
		if (type.ClientType.ChildItemClientType != null && type.ClientType.ChildItemClientType.IsClientObject)
		{
#>

@property
def items(self) -> 'list of <#=type.ClientType.ChildItemClientType.PythonTypeName#>':
    <#=Constants.MemberFullNames.ThrowIfNotLoaded#>("items", self.__items)
    return self.__items

<#+
		}
	}

	private void WriteScalarProperties(ClientCallableTypeInfo type, XDocument xdoc)
	{
		foreach (ClientCallablePropertyInfo prop in type.ScalarProperties.Where(p => !p.ExcludedFromClientLibrary))
		{
			this.WriteLine(string.Empty);
#>
@property
def <#=NormalizeMemberName(Utility.ToCamelLowerCase(prop.Name))#>(self) -> '<#=prop.PropertyType.PythonTypeName#>':
    <#=Constants.MemberFullNames.ThrowIfNotLoaded#>("<#=Utility.ToCamelLowerCase(prop.Name)#>", self.<#=prop.PythonFieldName#>)
    return self.<#=prop.PythonFieldName#>

<#+
			if (!prop.IsReadonly)
			{
				this.WriteLine(string.Empty);
				// NOTE: Do *NOT* write JSDOC comments on setters. Doing so creates a doubled-up comment on the property in the final TypeScript / d.ts file.
				// Just writing the JSDOC comment on the getter is perfectly sufficient (and our underlying assumption is that there are
				// no such things as write-only properties -- that same assumption is already used above, when creating the getter).
#>
@<#=NormalizeMemberName(Utility.ToCamelLowerCase(prop.Name))#>.setter
def <#=NormalizeMemberName(Utility.ToCamelLowerCase(prop.Name))#>(self, value : '<#=prop.PropertyType.PythonTypeName#>'):
    self.<#=prop.PythonFieldName#> = value
    <#=Constants.MemberFullNames.CreateSetPropertyAction#>(self.context, self, "<#=prop.Name#>", value)

<#+	
			}
		}
	}

	private void WriteMethods(ClientCallableTypeInfo type, XDocument xdoc, string[] existingFileContent)
	{
		foreach (ClientCallableMethodInfo method in type.Methods.Where(m => m.ShouldGenerateScriptMethod))
		{
			this.WriteLine(string.Empty);
			if (method.ReturnType.IsClientObject)
			{
				if (method.IsIndexerMethod)
				{
					WriteIndexerMethod(type, method, xdoc, existingFileContent);
				}
				else
				{
					WriteObjectMethod(type, method, xdoc, existingFileContent);
				}
			}
			else
			{
				if (method.ReturnType.IsVoid)
				{
					WriteScalarMethodReturnVoid(type, method, xdoc, existingFileContent);
				}
				else
				{
					WriteScalarMethodReturnValue(type, method, xdoc, existingFileContent);
				}
			}
		}
	}

	private void WriteScalarMethodReturnVoid(ClientCallableTypeInfo type, ClientCallableMethodInfo method, XDocument xdoc, string[] existingFileContent)
	{
#>
def <#=NormalizeMemberName(Utility.ToCamelLowerCase(method.Name))#>(<#=BuildMethodParameterList(method)#>) -> None:
<#+
		this.PushIndent(Constants.IndentString);
		this.WritePlaceHolderContent(type.Name + "_" + method.Name, existingFileContent);
		this.PopIndent();
#>
    <#=Constants.MemberFullNames.CreateMethodAction#>(self.context, self, "<#=method.Name#>", <#=Constants.TypeFullNames.OperationType#>.<#=method.OperationType#>, <#=BuildMethodParameterValueArray(method)#>)
<#+
	}

	private void WriteScalarMethodReturnValue(ClientCallableTypeInfo type, ClientCallableMethodInfo method, XDocument xdoc, string[] existingFileContent)
	{
#>
def <#=NormalizeMemberName(Utility.ToCamelLowerCase(method.Name))#>(<#=BuildMethodParameterList(method)#>) -> <#=Constants.TypeFullNames.ClientResult#>:
<#+
		this.PushIndent(Constants.IndentSpaceString);
		this.WritePlaceHolderContent(type.Name + "_" + method.Name, existingFileContent);
		this.PopIndent();
#>
    action = <#=Constants.MemberFullNames.CreateMethodAction#>(self.context, self, "<#=method.Name#>", <#=Constants.TypeFullNames.OperationType#>.<#=method.OperationType#>, <#=BuildMethodParameterValueArray(method)#>)
    ret = <#=Constants.TypeFullNames.ClientResult#>()
    <#=Constants.MemberFullNames.AddActionResultHandler#>(self, action, ret)
    return ret
<#+
	}

	private void WriteObjectMethod(ClientCallableTypeInfo type, ClientCallableMethodInfo method, XDocument xdoc, string[] existingFileContent)
	{
#>
def <#=NormalizeMemberName(Utility.ToCamelLowerCase(method.Name))#>(<#=BuildMethodParameterList(method)#>) -> '<#=method.ReturnType.PythonTypeName#>':
<#+
		this.PushIndent(Constants.IndentString);
		this.WritePlaceHolderContent(type.Name + "_" + method.Name, existingFileContent);
		this.PopIndent();

#>
    return <#=method.ReturnType.PythonTypeName#>(self.context, <#=Constants.MemberFullNames.CreateMethodObjectPath#>(self.context, self, "<#=method.Name#>", <#=Constants.TypeFullNames.OperationType#>.<#=method.OperationType#>, <#=BuildMethodParameterValueArray(method)#>, <#=Utility.GetPythonBooleanLiteral(method.ReturnType.IsClientObjectCollection)#>, <#=Utility.GetPythonBooleanLiteral(method.InvalidateReturnObjectPathAfterRequest)#>))
<#+
	}
	
	private void WriteIndexerMethod(ClientCallableTypeInfo type, ClientCallableMethodInfo method, XDocument xdoc, string[] existingFileContent)
	{
#>
def <#=NormalizeMemberName(Utility.ToCamelLowerCase(method.Name))#>(<#=BuildMethodParameterList(method)#>) -> '<#=method.ReturnType.PythonTypeName#>':
<#+
		this.PushIndent(Constants.IndentString);
		this.WritePlaceHolderContent(type.Name + "_" + method.Name, existingFileContent);
		this.PopIndent();
#>
    return <#=method.ReturnType.PythonTypeName#>(self.context, <#=Constants.MemberFullNames.CreateIndexerObjectPath#>(self.context, self, <#=BuildMethodParameterValueArray(method)#>))
<#+
	}

	private void WriteNewObject(ClientCallableTypeInfo type)
	{
#>
@staticmethod
def newObject(context: <#=Constants.TypeFullNames.ClientRequestContext#>) -> '<#=type.ClientType.PythonTypeName#>':
    var ret = <#=type.ClientType.PythonTypeName#>(context, <#=Constants.MemberFullNames.CreateNewObjectObjectPath#>(context, "<#=type.FullName#>", <#=Utility.GetPythonBooleanLiteral(type.ClientType.IsClientObjectCollection)#>))
    return ret
	}
<#+
	}

	private string BuildMethodParameterList(ClientCallableMethodInfo method)
	{
		StringBuilder sb = new StringBuilder();
		sb.Append("self");
		for (int i = 0; i < method.Parameters.Count; i++)
		{
			ClientCallableParameterInfo param = method.Parameters[i];
			sb.Append(", ");

			sb.Append(NormalizeMemberName(param.Name));
			sb.Append(" : ");
			sb.Append("'");
			sb.Append(param.ParameterType.PythonTypeName);
			sb.Append("'");
		}

		return sb.ToString();
	}

	private string BuildMethodParameterValueArray(ClientCallableMethodInfo method)
	{
		StringBuilder sb = new StringBuilder();
		sb.Append("[");
		for (int i = 0; i < method.Parameters.Count; i++)
		{
			if (i != 0)
			{
				sb.Append(", ");
			}

			sb.Append(NormalizeMemberName(method.Parameters[i].Name));
		}

		sb.Append("]");
		return sb.ToString();
	}

	private void WriteHandleResult(ClientCallableTypeInfo type)
	{
#>
# Handle results returned from the document
def _handleResult(self, value: dict) -> None:
    if <#=Constants.MemberFullNames.IsNullOrUndefined#>(value):
        return
    obj = value;
    <#=Constants.MemberFullNames.FixObjectPathIfNecessary#>(self, obj);
<#+
		foreach(ClientCallablePropertyInfo prop in type.ScalarProperties.Where(p => !p.ExcludedFromClientLibrary))
		{
#>
    if not <#=Constants.MemberFullNames.IsUndefined#>(obj.get("<#=prop.Name#>")):
        self.<#=prop.PythonFieldName#> = obj.get("<#=prop.Name#>")
<#+
		}

		List<string> navPropNames = new List<string>();
		foreach (ClientCallablePropertyInfo prop in type.ObjectProperties.Where(p => !p.IsVolatile && !p.ExcludedFromClientLibrary))
		{
#>
    if not <#=Constants.MemberFullNames.IsUndefined#>(obj.get("<#=prop.Name#>")):
        self.<#=Utility.ToCamelLowerCase(prop.Name)#>._handleResult(obj.get("<#=prop.Name#>"))
<#+
		}

		if (type.ClientType.ChildItemClientType != null && type.ClientType.ChildItemClientType.IsClientObject)
		{
			bool hasIndexerMethod = (type.Methods.FirstOrDefault(m => m.IsIndexerMethod) != null);
#>
    if not <#=Constants.MemberFullNames.IsNullOrUndefined#>(obj.get(OfficeExtension.Constants.items)):
        self.__items = []
        data = obj.get(OfficeExtension.Constants.items)
        for i, itemData in enumerate(data):
            item = <#=type.ClientType.ChildItemClientType.PythonTypeName#>(self.context, <#=Constants.MemberFullNames.CreateChildItemObjectPathUsingIndexerOrGetItemAt#>(<#=Utility.GetPythonBooleanLiteral(hasIndexerMethod)#>, self.context, self, itemData, i))
            item._handleResult(itemData)
            self.__items.append(item)
<#+
		}
	}

	private void WriteInitReferenceIdMethod(ClientCallableTypeInfo type)
	{
		ClientCallablePropertyInfo prop = type.ScalarProperties.FirstOrDefault(p => p.Name == Constants.MemberNames.ReferenceId);
		if (!type.IsValueObject && prop != null)
		{
#>
def _initReferenceId(self, value: str) -> None:
    self.<#=prop.PythonFieldName#> = value;
<#+
		}
	}

	private void WriteLoadMethod(ClientCallableTypeInfo type)
	{
		if (!type.IsValueObject)
		{
			// Only add a "load" method on objects that have properties or are collections.
			// Otherwise, for something like the Excel "Functions" object, since it's just a namespace placeholder object
			// with no actual properties on it, having "load" is only confusing.
			if (type.Properties.Any() || (type.ClientType.ChildItemClientType != null)) {
				var clientTypeOrCustomTypescriptName = string.IsNullOrEmpty(type.CustomTypeScriptTypeName) ? type.ClientType.TypeScriptTypeName : type.CustomTypeScriptTypeName;
#>

def load(self, option = None) -> '<#=type.ClientType.PythonTypeName#>':
    <#=Constants.MemberFullNames.Load#>(self, option);
<#+
			}
		}
	}

	private void WriteClientValueObjectType(ClientCallableTypeInfo type, XDocument xdoc, string[] existingFileContent)
	{
#>
class <#=type.Name#>:
<#+
		this.PushIndent(Constants.IndentSpaceString);
#>
def __init__(self):
<#+
		this.PushIndent(Constants.IndentSpaceString);
		foreach (ClientCallablePropertyInfo prop in type.Properties.Where(p => !p.ExcludedFromClientLibrary))
		{
#>
self.<#=Utility.ToCamelLowerCase(prop.Name)#> = None
<#+
		}
		this.PopIndent();
		this.WriteLine(string.Empty);
		this.WritePlaceHolderContent(type.Name + "_Custom_Members", existingFileContent);
		this.PopIndent();
		this.WriteLine(string.Empty);
	}
#>
