<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Xml" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="Helper.tt" #>
<#@ include file="Core.tt" #>
<#@ output extension=".txt" #>
<#+
	void WritePython()
	{
		this.LaunchDebuggerIfNecessary();
		if (this.CheckInputParameters())
		{
			this.UsePoundCommentStyle = true;
			CodeGenTemplateFileManager templateFileManager = new CodeGenTemplateFileManager(this.GenerationEnvironment);
			templateFileManager.StartHeader();

#>
#
# This is a generated file. <#=this.CreatedByToolStatement#>
# If there are content placeholders, only edit content inside content placeholders.
# If there are no content placeholders, do not edit this file directly.
#

<#+
			templateFileManager.EndBlock();

			templateFileManager.StartNewFile(this.FileBaseName.ToLowerInvariant() + ".py");
			this.WritePythonBody(System.IO.Path.Combine(this.OutputDirectory, this.FileBaseName + ".py"));
			templateFileManager.EndBlock();
			
			templateFileManager.WriteTo(this.OutputDirectory, this.CheckoutCommandPrefix);
		}
	}

	void WritePythonBody(string existingFilePath)
	{
		string[] existingFileContent = new string[0];
		if (File.Exists(existingFilePath))
		{
			existingFileContent = File.ReadAllLines(existingFilePath);
		}
#>
import sys
import json
import enum
import datetime
import logging
<#+
		this.WriteLine(string.Empty);
		this.WritePlaceHolderContent("GlobalHeader", existingFileContent);
		this.WriteLine(string.Empty);

		this.WriteMethodAlias();

		XDocument xdoc;
		if (string.IsNullOrWhiteSpace(this.DocXmlFilePath))
		{
			xdoc = new XDocument();
		}
		else
		{
			xdoc = XDocument.Load(this.DocXmlFilePath);
		}

		AssemblyReader assemblyReader = new AssemblyReader(this.InputFilePath, null, this.ReferencedAssemblyPaths, this.MaxVersion);
		assemblyReader.Process();
		List<string> namespaceStack = new List<string>();
		foreach (ClientCallableTypeInfo type in assemblyReader.Types.Where(t => !PythonUtility.ShouldSkipType(t)))
		{
			this.WriteLine(string.Empty);
			WriteType(type, xdoc, existingFileContent);
		}

		this.WriteLine(string.Empty);
		this.WritePlaceHolderContent("GlobalFooter", existingFileContent);
		this.WriteLine(string.Empty);
	}

	private void WriteMethodAlias()
	{
#>
_createPropertyObjectPath = OfficeExtension.ObjectPathFactory.createPropertyObjectPath
_createMethodObjectPath = OfficeExtension.ObjectPathFactory.createMethodObjectPath
_createIndexerObjectPath = OfficeExtension.ObjectPathFactory.createIndexerObjectPath
_createNewObjectObjectPath = OfficeExtension.ObjectPathFactory.createNewObjectObjectPath
_createChildItemObjectPathUsingIndexer = OfficeExtension.ObjectPathFactory.createChildItemObjectPathUsingIndexer
_createChildItemObjectPathUsingGetItemAt = OfficeExtension.ObjectPathFactory.createChildItemObjectPathUsingGetItemAt
_createChildItemObjectPathUsingIndexerOrGetItemAt = OfficeExtension.ObjectPathFactory.createChildItemObjectPathUsingIndexerOrGetItemAt
_createMethodAction = OfficeExtension.ActionFactory.createMethodAction
_createSetPropertyAction = OfficeExtension.ActionFactory.createSetPropertyAction
_isNullOrUndefined = OfficeExtension.Utility.isNullOrUndefined
_isUndefined = OfficeExtension.Utility.isUndefined
_throwIfNotLoaded = OfficeExtension.Utility.throwIfNotLoaded
_loadIfInstantSyncExecutionMode = OfficeExtension.Utility.loadIfInstantSyncExecutionMode
_syncIfInstantSyncExecutionMode = OfficeExtension.Utility.syncIfInstantSyncExecutionMode
_load = OfficeExtension.Utility.load
_fixObjectPathIfNecessary = OfficeExtension.Utility.fixObjectPathIfNecessary
_addActionResultHandler = OfficeExtension.Utility._addActionResultHandler
<#+
	}

	private void WriteErrorCode(IEnumerable<string> errorCodes)
	{
#>

class ErrorCodes:
{
<#+
		this.PushIndent(PythonUtility.IndentSpaceString);
		foreach(string errorCode in errorCodes.OrderBy(s => s))
		{
#>
<#=Utility.ToCamelLowerCase(errorCode)#>= "<#=errorCode#>"
<#+
		}
		this.PopIndent();
#>
}

<#+
	}

	private void WriteType(ClientCallableTypeInfo type, XDocument xdoc, string[] existingFileContent)
	{
		if (type.IsEnum)
		{
			WriteEnumType(type, xdoc);
		}
		else if (type.IsValueObject)
		{
			WriteClientValueObjectType(type, xdoc, existingFileContent);
		}
		else
		{
			WriteClientObjectType(type, xdoc, existingFileContent);
		}
	}

	private string NormalizeMemberName(string name)
	{
		string[] keywords = new string[] 
			{
				"and",
				"or",
				"lambda",
				"if",
				"not",
				"yield",
			};

		if (keywords.Contains(name))
		{
			return  name + "_";
		}

		return name;
	}

	private void WriteEnumType(ClientCallableTypeInfo type, XDocument xdoc)
	{
#>
class <#=type.Name#>:
<#+
		this.PushIndent(PythonUtility.IndentSpaceString);
		foreach (KeyValuePair<string, int> field in type.EnumFields)
		{
#>
<#=NormalizeMemberName(Utility.ToCamelLowerCase(field.Key))#> = "<#=Utility.TrimUnderscore(field.Key)#>"
<#+
		}
		this.PopIndent();
	}

	private void WriteClientObjectType(ClientCallableTypeInfo type, XDocument xdoc, string[] existingFileContent)
	{
		string typeNameOrCustom = string.IsNullOrEmpty(type.CustomTypeScriptTypeName) ? type.Name : type.CustomTypeScriptTypeName;
#>
class <#= type.Name #>(<#=Constants.TypeFullNames.ClientObject#>):
<#+
		this.PushIndent(PythonUtility.IndentSpaceString);
		this.WritePlaceHolderContent(type.Name + "_Custom_Members", existingFileContent);
		WriteConstructor(type);
		this.WriteLine(string.Empty);
		WriteObjectProperties(type, xdoc);
		WriteScalarProperties(type, xdoc);
		WriteMethods(type, xdoc, existingFileContent);
		this.WriteLine(string.Empty);
		WriteHandleResult(type);
		WriteLoadMethod(type);
		WriteHandleIdResultMethod(type);
		if (type.AllowCreation)
		{
			this.WriteLine(string.Empty);
			WriteNewObject(type);
		}
		this.PopIndent();
	}

	private void WriteConstructor(ClientCallableTypeInfo type)
	{
#>
def __init__(self, context: <#=Constants.TypeFullNames.ClientRequestContext#>, objectPath: <#= Constants.TypeFullNames.ObjectPath #>):
<#+
		this.PushIndent(PythonUtility.IndentSpaceString);
#>
super(self.__class__, self).__init__(context, objectPath)
<#+
		foreach (ClientCallablePropertyInfo prop in type.Properties.Where(p => !p.IsVolatile && !p.ExcludedFromClientLibrary && !PythonUtility.ShouldSkipProperty(p)))
		{
#>
self._<#=Utility.ToCamelLowerCase(prop.Name)#> = None
<#+
		}

		if (type.ClientType.ChildItemClientType != null && type.ClientType.ChildItemClientType.IsClientObject)
		{
#>
self.__items = None
<#+
		}

		this.PopIndent();
	}

	private void WriteObjectProperties(ClientCallableTypeInfo type, XDocument xdoc)
	{
		foreach (ClientCallablePropertyInfo prop in type.ObjectProperties.Where(p => !p.IsVolatile && !p.ExcludedFromClientLibrary && !PythonUtility.ShouldSkipProperty(p)))
		{
#>
@property
def <#=NormalizeMemberName(Utility.ToCamelLowerCase(prop.Name))#>(self) -> '<#=PythonUtility.GetPythonTypeName(prop.PropertyType)#>':
    if self.<#=PythonUtility.GetPythonFieldName(prop)#> is None:
        self.<#=PythonUtility.GetPythonFieldName(prop)#> = <#=PythonUtility.GetPythonTypeName(prop.PropertyType)#>(self.context, <#=PythonConstants.MemberFullNames.CreatePropertyObjectPath#>(self.context, self, "<#=prop.Name#>", <#=PythonUtility.GetPythonBooleanLiteral(prop.PropertyType.IsClientObjectCollection)#>, False))
    return self.<#=PythonUtility.GetPythonFieldName(prop)#>
<#+
			if (!prop.IsReadonly)
			{
#>

@<#=Utility.ToCamelLowerCase(prop.Name)#>.setter
def <#=NormalizeMemberName(Utility.ToCamelLowerCase(prop.Name))#>(self, value: '<#=PythonUtility.GetPythonTypeName(prop.PropertyType)#>') -> None:
    self.<#=PythonUtility.GetPythonFieldName(prop)#> = value
    <#=PythonConstants.MemberFullNames.CreateSetPropertyAction#>(self.context, self, "<#=prop.Name#>", value);
<#+	
			}
		}

		foreach (ClientCallablePropertyInfo prop in type.ObjectProperties.Where(p => p.IsVolatile && !p.ExcludedFromClientLibrary && !PythonUtility.ShouldSkipProperty(p)))
		{
			this.WriteLine(string.Empty);
#>
def get<#=Utility.ToCamelUpperCase(prop.Name)#>(self) -> '<#=PythonUtility.GetPythonTypeName(prop.PropertyType)#>':
    return <#=PythonUtility.GetPythonTypeName(prop.PropertyType)#>(self.context, <#=PythonConstants.MemberFullNames.CreatePropertyObjectPath#>(self.context, self, "<#=prop.Name#>", <#=PythonUtility.GetPythonBooleanLiteral(prop.PropertyType.IsClientObjectCollection)#>, <#=PythonUtility.GetPythonBooleanLiteral(prop.InvalidateReturnObjectPathAfterRequest)#>))
<#+
			if (!prop.IsReadonly)
			{
				this.WriteLine(string.Empty);
				// NOTE: Do *NOT* write JSDOC comments on setters. Doing so creates a doubled-up comment on the property in the final TypeScript / d.ts file.
				// Just writing the JSDOC comment on the getter is perfectly sufficient (and our underlying assumption is that there are
				// no such things as write-only properties -- that same assumption is already used above, when creating the getter).
#>
def set<#=Utility.ToCamelUpperCase(prop.Name)#>(self, value -> '<#=PythonUtility.GetPythonTypeName(prop.PropertyType)#>') -> None:
    <#=PythonConstants.MemberFullNames.CreateSetPropertyAction#>(self.context, self, "<#=prop.Name#>", value)
<#+
			}
		}

		// child items
		if (type.ClientType.ChildItemClientType != null && type.ClientType.ChildItemClientType.IsClientObject)
		{
#>

@property
def items(self) -> 'list of <#=PythonUtility.GetPythonTypeName(type.ClientType.ChildItemClientType)#>':
    <#=PythonConstants.MemberFullNames.LoadIfInstantSyncExecutionMode#>(self, "items", self.__items)
    <#=PythonConstants.MemberFullNames.ThrowIfNotLoaded#>("items", self.__items, "<#=type.Name#>", self._isNull)
    return self.__items

<#+
		}
	}

	private void WriteScalarProperties(ClientCallableTypeInfo type, XDocument xdoc)
	{
		foreach (ClientCallablePropertyInfo prop in type.ScalarProperties.Where(p => !p.ExcludedFromClientLibrary && !PythonUtility.ShouldSkipProperty(p)))
		{
			this.WriteLine(string.Empty);
#>
@property
def <#=NormalizeMemberName(Utility.ToCamelLowerCase(prop.Name))#>(self) -> '<#=PythonUtility.GetPythonTypeName(prop.PropertyType)#>':
    <#=PythonConstants.MemberFullNames.LoadIfInstantSyncExecutionMode#>(self, "<#=Utility.ToCamelLowerCase(prop.Name)#>", self.<#=PythonUtility.GetPythonFieldName(prop)#>)
    <#=PythonConstants.MemberFullNames.ThrowIfNotLoaded#>("<#=Utility.ToCamelLowerCase(prop.Name)#>", self.<#=PythonUtility.GetPythonFieldName(prop)#>, "<#=type.Name#>", self._isNull)
    return self.<#=PythonUtility.GetPythonFieldName(prop)#>

<#+
			if (!prop.IsReadonly)
			{
				this.WriteLine(string.Empty);
				// NOTE: Do *NOT* write JSDOC comments on setters. Doing so creates a doubled-up comment on the property in the final TypeScript / d.ts file.
				// Just writing the JSDOC comment on the getter is perfectly sufficient (and our underlying assumption is that there are
				// no such things as write-only properties -- that same assumption is already used above, when creating the getter).
#>
@<#=NormalizeMemberName(Utility.ToCamelLowerCase(prop.Name))#>.setter
def <#=NormalizeMemberName(Utility.ToCamelLowerCase(prop.Name))#>(self, value : '<#=PythonUtility.GetPythonTypeName(prop.PropertyType)#>'):
    self.<#=PythonUtility.GetPythonFieldName(prop)#> = value
    <#=PythonConstants.MemberFullNames.CreateSetPropertyAction#>(self.context, self, "<#=prop.Name#>", value)
    <#=PythonConstants.MemberFullNames.SyncIfInstantSyncExecutionMode#>(self)
<#+	
			}
		}
	}

	private void WriteMethods(ClientCallableTypeInfo type, XDocument xdoc, string[] existingFileContent)
	{
		foreach (ClientCallableMethodInfo method in type.Methods.Where(m => m.ShouldGenerateScriptMethod))
		{
			this.WriteLine(string.Empty);
			if (method.ReturnType.IsClientObject)
			{
				if (method.IsIndexerMethod)
				{
					WriteIndexerMethod(type, method, xdoc, existingFileContent);
				}
				else
				{
					WriteObjectMethod(type, method, xdoc, existingFileContent);
				}
			}
			else
			{
				if (method.ReturnType.IsVoid)
				{
					WriteScalarMethodReturnVoid(type, method, xdoc, existingFileContent);
				}
				else
				{
					WriteScalarMethodReturnValue(type, method, xdoc, existingFileContent);
				}
			}
		}
	}

	private void WriteScalarMethodReturnVoid(ClientCallableTypeInfo type, ClientCallableMethodInfo method, XDocument xdoc, string[] existingFileContent)
	{
#>
def <#=NormalizeMemberName(Utility.ToCamelLowerCase(method.Name))#>(<#=BuildMethodParameterList(method)#>) -> None:
<#+
		this.PushIndent(PythonUtility.IndentSpaceString);
		this.WritePlaceHolderContent(type.Name + "_" + method.Name, existingFileContent);
		this.PopIndent();
#>
    <#=PythonConstants.MemberFullNames.CreateMethodAction#>(self.context, self, "<#=method.Name#>", <#=Constants.TypeFullNames.OperationType#>.<#=method.OperationType#>, <#=BuildMethodParameterValueArray(method)#>)
    <#=PythonConstants.MemberFullNames.SyncIfInstantSyncExecutionMode#>(self)
<#+
	}

	private void WriteScalarMethodReturnValue(ClientCallableTypeInfo type, ClientCallableMethodInfo method, XDocument xdoc, string[] existingFileContent)
	{
#>
def <#=NormalizeMemberName(Utility.ToCamelLowerCase(method.Name))#>(<#=BuildMethodParameterList(method)#>) -> <#=Constants.TypeFullNames.ClientResult#>:
<#+
		this.PushIndent(PythonUtility.IndentSpaceString);
		this.WritePlaceHolderContent(type.Name + "_" + method.Name, existingFileContent);
		this.PopIndent();
		string clientResultType = "";
		if (method.ReturnType.IsDateTimeOrDateTimeArray)
		{
			clientResultType = "OfficeExtension.ClientResultProcessingType.date";
		}

#>
    action = <#=PythonConstants.MemberFullNames.CreateMethodAction#>(self.context, self, "<#=method.Name#>", <#=Constants.TypeFullNames.OperationType#>.<#=method.OperationType#>, <#=BuildMethodParameterValueArray(method)#>)
    ret = <#=Constants.TypeFullNames.ClientResult#>(<#=clientResultType#>)
    <#=PythonConstants.MemberFullNames.AddActionResultHandler#>(self, action, ret)
    <#=PythonConstants.MemberFullNames.SyncIfInstantSyncExecutionMode#>(self)
    return ret
<#+
	}

	private void WriteObjectMethod(ClientCallableTypeInfo type, ClientCallableMethodInfo method, XDocument xdoc, string[] existingFileContent)
	{
#>
def <#=NormalizeMemberName(Utility.ToCamelLowerCase(method.Name))#>(<#=BuildMethodParameterList(method)#>) -> '<#=PythonUtility.GetPythonTypeName(method.ReturnType)#>':
<#+
		this.PushIndent(PythonUtility.IndentSpaceString);
		this.WritePlaceHolderContent(type.Name + "_" + method.Name, existingFileContent);
		this.PopIndent();

#>
    ret = <#=PythonUtility.GetPythonTypeName(method.ReturnType)#>(self.context, <#=PythonConstants.MemberFullNames.CreateMethodObjectPath#>(self.context, self, "<#=method.Name#>", <#=Constants.TypeFullNames.OperationType#>.<#=method.OperationType#>, <#=BuildMethodParameterValueArray(method)#>, <#=PythonUtility.GetPythonBooleanLiteral(method.ReturnType.IsClientObjectCollection)#>, <#=PythonUtility.GetPythonBooleanLiteral(method.InvalidateReturnObjectPathAfterRequest)#>))
<#+
		if (PythonUtility.ShouldAddInstantSyncExecutionForObjectMethod(method))
		{
#>
    <#=PythonConstants.MemberFullNames.SyncIfInstantSyncExecutionMode#>(self)
<#+
		}
#>
    return ret
<#+
	}
	
	private void WriteIndexerMethod(ClientCallableTypeInfo type, ClientCallableMethodInfo method, XDocument xdoc, string[] existingFileContent)
	{
#>
def <#=NormalizeMemberName(Utility.ToCamelLowerCase(method.Name))#>(<#=BuildMethodParameterList(method)#>) -> '<#=PythonUtility.GetPythonTypeName(method.ReturnType)#>':
<#+
		this.PushIndent(PythonUtility.IndentSpaceString);
		this.WritePlaceHolderContent(type.Name + "_" + method.Name, existingFileContent);
		this.PopIndent();
#>
    return <#=PythonUtility.GetPythonTypeName(method.ReturnType)#>(self.context, <#=PythonConstants.MemberFullNames.CreateIndexerObjectPath#>(self.context, self, <#=BuildMethodParameterValueArray(method)#>))
<#+
	}

	private void WriteNewObject(ClientCallableTypeInfo type)
	{
#>
@staticmethod
def newObject(context: <#=Constants.TypeFullNames.ClientRequestContext#>) -> '<#=PythonUtility.GetPythonTypeName(type.ClientType)#>':
    ret = <#=PythonUtility.GetPythonTypeName(type.ClientType)#>(context, <#=PythonConstants.MemberFullNames.CreateNewObjectObjectPath#>(context, "<#=type.FullName#>", <#=PythonUtility.GetPythonBooleanLiteral(type.ClientType.IsClientObjectCollection)#>))
    return ret

<#+
	}

	private string BuildMethodParameterList(ClientCallableMethodInfo method)
	{
		StringBuilder sb = new StringBuilder();
		sb.Append("self");
		for (int i = 0; i < method.Parameters.Count; i++)
		{
			ClientCallableParameterInfo param = method.Parameters[i];
			sb.Append(", ");

			sb.Append(NormalizeMemberName(param.Name));
			sb.Append(" : ");
			sb.Append("'");
			sb.Append(PythonUtility.GetPythonTypeName(param.ParameterType));
			sb.Append("'");
			if (param.IsOptional)
			{
				sb.Append(" = None");
			}
		}

		return sb.ToString();
	}

	private string BuildMethodParameterValueArray(ClientCallableMethodInfo method)
	{
		StringBuilder sb = new StringBuilder();
		sb.Append("[");
		for (int i = 0; i < method.Parameters.Count; i++)
		{
			if (i != 0)
			{
				sb.Append(", ");
			}

			sb.Append(NormalizeMemberName(method.Parameters[i].Name));
		}

		sb.Append("]");
		return sb.ToString();
	}

	private void WriteHandleResult(ClientCallableTypeInfo type)
	{
#>
# Handle results returned from the document
def _handleResult(self, value: dict) -> None:
    super(self.__class__, self)._handleIdResult(value)
    if <#=PythonConstants.MemberFullNames.IsNullOrUndefined#>(value):
        return
    obj = value;
<#+
		foreach(ClientCallablePropertyInfo prop in type.ScalarProperties.Where(p => !p.ExcludedFromClientLibrary && !PythonUtility.ShouldSkipProperty(p)))
		{
#>
    if "<#=prop.Name#>" in obj:
<#+
			if (prop.PropertyType.IsDateTimeOrDateTimeArray)
			{
#>
        self.<#=PythonUtility.GetPythonFieldName(prop)#> = <#=PythonConstants.MemberFullNames.AdjustToDateTime#>(obj.get("<#=prop.Name#>"))
<#+
			}
			else
			{
#>
        self.<#=PythonUtility.GetPythonFieldName(prop)#> = obj.get("<#=prop.Name#>")
<#+
			}
		}

		List<string> navPropNames = new List<string>();
		foreach (ClientCallablePropertyInfo prop in type.ObjectProperties.Where(p => !p.IsVolatile && !p.ExcludedFromClientLibrary && !PythonUtility.ShouldSkipProperty(p)))
		{
#>
    if "<#=prop.Name#>" in obj:
        self.<#=Utility.ToCamelLowerCase(prop.Name)#>._handleResult(obj.get("<#=prop.Name#>"))
<#+
		}

		if (type.ClientType.ChildItemClientType != null && type.ClientType.ChildItemClientType.IsClientObject)
		{
			bool hasIndexerMethod = (type.Methods.FirstOrDefault(m => m.IsIndexerMethod) != null);
#>
    if OfficeExtension.Constants.items in obj:
        self.__items = []
        data = obj.get(OfficeExtension.Constants.items)
        for i, itemData in enumerate(data):
            item = <#=PythonUtility.GetPythonTypeName(type.ClientType.ChildItemClientType)#>(self.context, <#=PythonConstants.MemberFullNames.CreateChildItemObjectPathUsingIndexerOrGetItemAt#>(<#=PythonUtility.GetPythonBooleanLiteral(hasIndexerMethod)#>, self.context, self, itemData, i))
            item._handleResult(itemData)
            self.__items.append(item)
<#+
		}
	}

	private void WriteHandleIdResultMethod(ClientCallableTypeInfo type)
	{
		if (!type.IsValueObject)
		{
			List<ClientCallablePropertyInfo> props = new List<ClientCallablePropertyInfo>();
			props.Add(type.ScalarProperties.FirstOrDefault(p => p.Name == Constants.MemberNames.ReferenceId));
			props.Add(type.ScalarProperties.FirstOrDefault(p => p.Name == Constants.MemberNames.Id));
			props.Add(type.ScalarProperties.FirstOrDefault(p => p.Name == Constants.MemberNames.IdPrivate));
			

			if (props.Any((prop) => prop != null && !prop.ExcludedFromClientLibrary))
			{
#>
def _handleIdResult(self, value) -> None:
    super(self.__class__, self)._handleIdResult(value)
    if value is None:
        return
<#+
				foreach(ClientCallablePropertyInfo prop in props)
				{
					if (prop != null && !prop.ExcludedFromClientLibrary)
					{
#>
    if "<#=prop.Name#>" in value:
        self.<#=PythonUtility.GetPythonFieldName(prop)#> = value.get("<#=prop.Name#>")
<#+
					}
				}
			}
		}
	}

	private void WriteLoadMethod(ClientCallableTypeInfo type)
	{
		if (!type.IsValueObject)
		{
			// Only add a "load" method on objects that have properties or are collections.
			// Otherwise, for something like the Excel "Functions" object, since it's just a namespace placeholder object
			// with no actual properties on it, having "load" is only confusing.
			if (type.Properties.Any() || (type.ClientType.ChildItemClientType != null)) {
				var clientTypeOrCustomTypescriptName = string.IsNullOrEmpty(type.CustomTypeScriptTypeName) ? type.ClientType.TypeScriptTypeName : type.CustomTypeScriptTypeName;
#>

def load(self, option = None) -> '<#=PythonUtility.GetPythonTypeName(type.ClientType)#>':
    <#=PythonConstants.MemberFullNames.Load#>(self, option);
<#+
			}
		}
	}

	private void WriteClientValueObjectType(ClientCallableTypeInfo type, XDocument xdoc, string[] existingFileContent)
	{
#>
class <#=type.Name#>:
<#+
		this.PushIndent(PythonUtility.IndentSpaceString);
#>
def __init__(self):
<#+
		this.PushIndent(PythonUtility.IndentSpaceString);
		foreach (ClientCallablePropertyInfo prop in type.Properties.Where(p => !p.ExcludedFromClientLibrary && !PythonUtility.ShouldSkipProperty(p)))
		{
#>
self.<#=Utility.ToCamelLowerCase(prop.Name)#> = None
<#+
		}
		this.PopIndent();
		this.WriteLine(string.Empty);
		this.WritePlaceHolderContent(type.Name + "_Custom_Members", existingFileContent);
		this.PopIndent();
		this.WriteLine(string.Empty);
	}

	public static class PythonConstants
	{
		[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1034:NestedTypesShouldNotBeVisible")]
		public static class MemberFullNames
		{
			public const string CreatePropertyObjectPath = "_createPropertyObjectPath";
			public const string CreateMethodObjectPath = "_createMethodObjectPath";
			public const string CreateIndexerObjectPath = "_createIndexerObjectPath";
			public const string CreateNewObjectObjectPath = "_createNewObjectObjectPath";
			public const string CreateChildItemObjectPathUsingIndexer = "_createChildItemObjectPathUsingIndexer";
			public const string CreateChildItemObjectPathUsingGetItemAt = "_createChildItemObjectPathUsingGetItemAt";
			public const string CreateChildItemObjectPathUsingIndexerOrGetItemAt = "_createChildItemObjectPathUsingIndexerOrGetItemAt";

			public const string CreateSetPropertyAction = "_createSetPropertyAction";
			public const string CreateMethodAction = "_createMethodAction";

			public const string IsNullOrUndefined = "_isNullOrUndefined";
			public const string IsUndefined = "_isUndefined";
			public const string ThrowIfNotLoaded = "_throwIfNotLoaded";
			public const string Load = "_load";
			public const string FixObjectPathIfNecessary = "_fixObjectPathIfNecessary";
			public const string AddActionResultHandler = "_addActionResultHandler";
			public const string HandleNavigationPropertyResults = "_handleNavigationPropertyResults";
			public const string AdjustToDateTime = "_adjustToDateTime";
			public const string LoadIfInstantSyncExecutionMode = "_loadIfInstantSyncExecutionMode";
			public const string SyncIfInstantSyncExecutionMode = "_syncIfInstantSyncExecutionMode";
		}
	}

	static class PythonUtility
	{
		public const string IndentSpaceString = "    ";
		public static string GetPythonBooleanLiteral(bool value)
		{
			if (value)
			{
				return "True";
			}

			return "False";
		}

		public static bool ShouldSkipType(ClientCallableTypeInfo type)
		{
			if (type.IsEventArgs)
			{
				return true;
			}

			if (type.Name.StartsWith("_", StringComparison.Ordinal) ||
				type.Name.StartsWith("V1", StringComparison.Ordinal))
			{
				return true;
			}

			return false;
		}

		public static bool ShouldSkipType(ClientType type)
		{
			if (type.ClientCallableType != null)
			{
				return ShouldSkipType(type.ClientCallableType);
			}

			return false;
		}

		public static bool ShouldSkipProperty(ClientCallablePropertyInfo prop)
		{
			if (prop.Name.StartsWith("_V1", StringComparison.Ordinal) ||
				prop.Name.StartsWith("V1", StringComparison.Ordinal))
			{
				return true;
			}

			if (ShouldSkipType(prop.PropertyType))
				return true;

			return false;
		}

		public static bool ShouldAddInstantSyncExecutionForObjectMethod(ClientCallableMethodInfo method)
		{
			if (method.Name == "Add")
			{
				return true;
			}

			return false;
		}

		public static string GetPythonFieldName(ClientCallablePropertyInfo prop)
		{
			return "_" + Utility.ToCamelLowerCase(prop.Name);
		}

		public static string GetPythonTypeName(ClientType type)
		{
			if (type == null)
			{
				throw new ArgumentNullException("type");
			}

			if (type.IsEnum)
			{
				return "str";
			}
			else if (type.IsStream)
			{
				return "str";
			}
			else if (type.IsClientObject || type.IsClientValueObject)
			{
				return type.ClientCallableType.Name;
			}
			else if (type.ChildItemClientType != null)
			{
				return "list";
			}
			else
			{
				switch (type.FullName)
				{
					case "System.Object":
						return "any";
					case "System.Int16":
					case "System.UInt16":
					case "System.Int32":
					case "System.UInt32":
						return "int";
					case "System.Single":
					case "System.Double":
						return "float";
					case "System.Boolean":
						return "bool";
					case "System.String":
						return "str";
					case "System.Void":
						return "None";
					case "System.DateTime":
						return "datetime.datetime";
					default:
						throw CodeGenException.CreateCodeGenException("Cannot handle type {0}", type.FullName);
				}
			}
		}

    }
#>
