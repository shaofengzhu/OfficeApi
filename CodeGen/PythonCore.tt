<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Xml" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="Helper.tt" #>
<#@ include file="Core.tt" #>
<#@ output extension=".txt" #>
<#+
	void WritePython()
	{
		this.LaunchDebuggerIfNecessary();
		if (this.CheckInputParameters())
		{
			this.UsePoundCommentStyle = true;
			CodeGenTemplateFileManager templateFileManager = new CodeGenTemplateFileManager(this.GenerationEnvironment);
			templateFileManager.StartHeader();

#>
#
# This is a generated file. <#=this.CreatedByToolStatement#>
# If there are content placeholders, only edit content inside content placeholders.
# If there are no content placeholders, do not edit this file directly.
#

<#+
			templateFileManager.EndBlock();

			templateFileManager.StartNewFile(this.FileBaseName + ".py");
			this.WritePythonBody(System.IO.Path.Combine(this.OutputDirectory, this.FileBaseName + ".py"));
			templateFileManager.EndBlock();
			
			templateFileManager.WriteTo(this.OutputDirectory, this.CheckoutCommandPrefix);
		}
	}

	void WritePythonBody(string existingFilePath)
	{
		string[] existingFileContent = new string[0];
		if (File.Exists(existingFilePath))
		{
			existingFileContent = File.ReadAllLines(existingFilePath);
		}

		this.WriteLine(string.Empty);
		this.WritePlaceHolderContent("GlobalHeader", existingFileContent);
		this.WriteLine(string.Empty);

		XDocument xdoc;
		if (string.IsNullOrWhiteSpace(this.DocXmlFilePath))
		{
			xdoc = new XDocument();
		}
		else
		{
			xdoc = XDocument.Load(this.DocXmlFilePath);
		}

		AssemblyReader assemblyReader = new AssemblyReader(this.InputFilePath, null, this.ReferencedAssemblyPaths);
		assemblyReader.Process();
		List<string> namespaceStack = new List<string>();
		foreach (ClientCallableTypeInfo type in assemblyReader.Types)
		{
			this.WriteLine(string.Empty);
			WriteType(type, xdoc, existingFileContent);
		}

		this.WriteLine(string.Empty);
		this.WritePlaceHolderContent("GlobalFooter", existingFileContent);
		this.WriteLine(string.Empty);
	}

	private void WriteErrorCode(IEnumerable<string> errorCodes)
	{
#>

class ErrorCodes:
{
<#+
		this.PushIndent(Constants.IndentSpaceString);
		foreach(string errorCode in errorCodes.OrderBy(s => s))
		{
#>
<#=Utility.ToCamelLowerCase(errorCode)#>= "<#=errorCode#>"
<#+
		}
		this.PopIndent();
#>
}

<#+
	}

	private void WriteType(ClientCallableTypeInfo type, XDocument xdoc, string[] existingFileContent)
	{
		if (type.IsEnum)
		{
			WriteEnumType(type, xdoc);
		}
		else if (type.IsValueObject)
		{
			WriteClientValueObjectType(type, xdoc, existingFileContent);
		}
		else
		{
			WriteClientObjectType(type, xdoc, existingFileContent);
		}
	}

	private void WriteEnumType(ClientCallableTypeInfo type, XDocument xdoc)
	{
#>
class <#=type.Name#>:
<#+
		this.PushIndent(Constants.IndentSpaceString);
		foreach (KeyValuePair<string, int> field in type.EnumFields)
		{
#>
<#=Utility.ToCamelLowerCase(field.Key)#> = "<#=Utility.TrimUnderscore(field.Key)#>"
<#+
		}
		this.PopIndent();
	}

	private void WriteClientObjectType(ClientCallableTypeInfo type, XDocument xdoc, string[] existingFileContent)
	{
		string typeNameOrCustom = string.IsNullOrEmpty(type.CustomTypeScriptTypeName) ? type.Name : type.CustomTypeScriptTypeName;
#>
class <#= type.Name #>(<#=Constants.TypeFullNames.ClientObject#>):
<#+
		this.PushIndent(Constants.IndentSpaceString);
		this.WritePlaceHolderContent(type.Name + "_Custom_Members", existingFileContent);
		WriteConstructor(type);
		WriteObjectProperties(type, xdoc);
		WriteScalarProperties(type, xdoc);
		WriteMethods(type, xdoc, existingFileContent);
		this.WriteLine(string.Empty);
		WriteHandleResult(type);
		WriteLoadMethod(type);
		WriteInitReferenceIdMethod(type);
		if (type.AllowCreation)
		{
			this.WriteLine(string.Empty);
			WriteNewObject(type);
		}
		this.PopIndent();
	}

	private void WriteConstructor(ClientCallableTypeInfo type)
	{
#>
def __init__(self, objectPath: ObjectPath):
<#+
		this.PushIndent(Constants.IndentSpaceString);
#>
super(self.__class__, self).__init__(self, objectPath)
<#+
		foreach (ClientCallablePropertyInfo prop in type.Properties.Where(p => !p.IsVolatile && !p.ExcludedFromClientLibrary))
		{
#>
self._<#=Utility.ToCamelLowerCase(prop.Name)#> = None
<#+
		}

		if (type.ClientType.ChildItemClientType != null && type.ClientType.ChildItemClientType.IsClientObject)
		{
#>
self.__items = None
<#+
		}

		this.PopIndent();
	}

	private void WriteObjectProperties(ClientCallableTypeInfo type, XDocument xdoc)
	{
		foreach (ClientCallablePropertyInfo prop in type.ObjectProperties.Where(p => !p.IsVolatile && !p.ExcludedFromClientLibrary))
		{
			this.PushIndent(Constants.IndentString);
#>
@property
def <#=Utility.ToCamelLowerCase(prop.Name)#>(self) -> '<#=prop.PropertyType.PythonTypeName#>':
    if self.<#=prop.PythonFieldName#> is None:
        self.<#=prop.PythonFieldName#> = <#=prop.PropertyType.PythonTypeName#>(self.context, <#=Constants.MemberFullNames.CreatePropertyObjectPath#>(self.context, self, "<#=prop.Name#>", <#=Utility.GetPythonBooleanLiteral(prop.PropertyType.IsClientObjectCollection)#>, False))
    return self.<#=prop.PythonFieldName#>
<#+
			if (!prop.IsReadonly)
			{
#>

@<#=Utility.ToCamelLowerCase(prop.Name)#>.setter
def <#=Utility.ToCamelLowerCase(prop.Name)#>(self, value: '<#=prop.PropertyType.PythonTypeName#>') -> None:
    self.<#=prop.PythonFieldName#> = value
    <#=Constants.MemberFullNames.CreateSetPropertyAction#>(self.context, self, "<#=prop.Name#>", value);
<#+	
			}
		}

		foreach (ClientCallablePropertyInfo prop in type.ObjectProperties.Where(p => p.IsVolatile && !p.ExcludedFromClientLibrary))
		{
			this.WriteLine(string.Empty);
#>
def get<#=Utility.ToCamelUpperCase(prop.Name)#>(self) -> '<#=prop.PropertyType.PythonTypeName#>':
    return <#=prop.PropertyType.PythonTypeName#>(self.context, <#=Constants.MemberFullNames.CreatePropertyObjectPath#>(self.context, self, "<#=prop.Name#>", <#=Utility.GetPythonBooleanLiteral(prop.PropertyType.IsClientObjectCollection)#>, <#=Utility.GetPythonBooleanLiteral(prop.InvalidateReturnObjectPathAfterRequest)#>))
<#+
			if (!prop.IsReadonly)
			{
				this.WriteLine(string.Empty);
				// NOTE: Do *NOT* write JSDOC comments on setters. Doing so creates a doubled-up comment on the property in the final TypeScript / d.ts file.
				// Just writing the JSDOC comment on the getter is perfectly sufficient (and our underlying assumption is that there are
				// no such things as write-only properties -- that same assumption is already used above, when creating the getter).
#>
def set<#=Utility.ToCamelUpperCase(prop.Name)#>(self, value -> '<#=prop.PropertyType.PythonTypeName#>') -> None:
    <#=Constants.MemberFullNames.CreateSetPropertyAction#>(self.context, self, "<#=prop.Name#>", value)
<#+
			}
		}

		// child items
		if (type.ClientType.ChildItemClientType != null && type.ClientType.ChildItemClientType.IsClientObject)
		{
#>

@property
def items(self) -> 'list of <#=type.ClientType.ChildItemClientType.PythonTypeName#>':
    <#=Constants.MemberFullNames.ThrowIfNotLoaded#>("items", self.__items)
    return self.__items

<#+
		}
	}

	private void WriteScalarProperties(ClientCallableTypeInfo type, XDocument xdoc)
	{
		foreach (ClientCallablePropertyInfo prop in type.ScalarProperties.Where(p => !p.ExcludedFromClientLibrary))
		{
			this.WriteLine(string.Empty);
#>
@property
def <#=Utility.ToCamelLowerCase(prop.Name)#>(self) -> '<#=prop.PropertyType.PythonTypeName#>':
    <#=Constants.MemberFullNames.ThrowIfNotLoaded#>("<#=Utility.ToCamelLowerCase(prop.Name)#>", self.<#=prop.PythonFieldName#>)
    return self.<#=prop.PythonFieldName#>

<#+
			if (!prop.IsReadonly)
			{
				this.WriteLine(string.Empty);
				// NOTE: Do *NOT* write JSDOC comments on setters. Doing so creates a doubled-up comment on the property in the final TypeScript / d.ts file.
				// Just writing the JSDOC comment on the getter is perfectly sufficient (and our underlying assumption is that there are
				// no such things as write-only properties -- that same assumption is already used above, when creating the getter).
#>
@<#=Utility.ToCamelLowerCase(prop.Name)#>.setter
def <#=Utility.ToCamelLowerCase(prop.Name)#>(self, value -> '<#=prop.PropertyType.PythonTypeName#>'):
    self.<#=prop.PythonFieldName#> = value
    <#=Constants.MemberFullNames.CreateSetPropertyAction#>(self.context, self, "<#=prop.Name#>", value)

<#+	
			}
		}
	}

	private void WriteMethods(ClientCallableTypeInfo type, XDocument xdoc, string[] existingFileContent)
	{
		foreach (ClientCallableMethodInfo method in type.Methods.Where(m => m.ShouldGenerateScriptMethod))
		{
			this.WriteLine(string.Empty);
			if (method.ReturnType.IsClientObject)
			{
				if (method.IsIndexerMethod)
				{
					WriteIndexerMethod(type, method, xdoc, existingFileContent);
				}
				else
				{
					WriteObjectMethod(type, method, xdoc, existingFileContent);
				}
			}
			else
			{
				if (method.ReturnType.IsVoid)
				{
					WriteScalarMethodReturnVoid(type, method, xdoc, existingFileContent);
				}
				else
				{
					WriteScalarMethodReturnValue(type, method, xdoc, existingFileContent);
				}
			}
		}
	}

	private void WriteScalarMethodReturnVoid(ClientCallableTypeInfo type, ClientCallableMethodInfo method, XDocument xdoc, string[] existingFileContent)
	{
#>
def <#=Utility.ToCamelLowerCase(method.Name)#>(<#=BuildMethodParameterList(method)#>) -> None:
<#+
		this.PushIndent(Constants.IndentString);
		this.WritePlaceHolderContent(type.Name + "_" + method.Name, existingFileContent);
		this.PopIndent();
#>
    <#=Constants.MemberFullNames.CreateMethodAction#>(self.context, self, "<#=method.Name#>", <#=Constants.TypeFullNames.OperationType#>.<#=method.OperationType#>, <#=BuildMethodParameterValueArray(method)#>)
	}
<#+
	}

	private void WriteScalarMethodReturnValue(ClientCallableTypeInfo type, ClientCallableMethodInfo method, XDocument xdoc, string[] existingFileContent)
	{
#>
def <#=Utility.ToCamelLowerCase(method.Name)#>(<#=BuildMethodParameterList(method)#>) -> <#=Constants.TypeFullNames.ClientResult#>:
<#+
		this.PushIndent(Constants.IndentSpaceString);
		this.WritePlaceHolderContent(type.Name + "_" + method.Name, existingFileContent);
		this.PopIndent();
#>
    action = <#=Constants.MemberFullNames.CreateMethodAction#>(self.context, self, "<#=method.Name#>", <#=Constants.TypeFullNames.OperationType#>.<#=method.OperationType#>, <#=BuildMethodParameterValueArray(method)#>)
    ret = <#=Constants.TypeFullNames.ClientResult#>()
    <#=Constants.MemberFullNames.AddActionResultHandler#>(self, action, ret)
    return ret
<#+
	}

	private void WriteObjectMethod(ClientCallableTypeInfo type, ClientCallableMethodInfo method, XDocument xdoc, string[] existingFileContent)
	{
#>
def <#=Utility.ToCamelLowerCase(method.Name)#>(<#=BuildMethodParameterList(method)#>) -> '<#=method.ReturnType.PythonTypeName#>':
<#+
		this.PushIndent(Constants.IndentString);
		this.WritePlaceHolderContent(type.Name + "_" + method.Name, existingFileContent);
		this.PopIndent();

#>
    return <#=method.ReturnType.PythonTypeName#>(self.context, <#=Constants.MemberFullNames.CreateMethodObjectPath#>(self.context, self, "<#=method.Name#>", <#=Constants.TypeFullNames.OperationType#>.<#=method.OperationType#>, <#=BuildMethodParameterValueArray(method)#>, <#=Utility.GetPythonBooleanLiteral(method.ReturnType.IsClientObjectCollection)#>, <#=Utility.GetPythonBooleanLiteral(method.InvalidateReturnObjectPathAfterRequest)#>))
<#+
	}
	
	private void WriteIndexerMethod(ClientCallableTypeInfo type, ClientCallableMethodInfo method, XDocument xdoc, string[] existingFileContent)
	{
#>
def <#=Utility.ToCamelLowerCase(method.Name)#>(<#=BuildMethodParameterList(method)#>) -> '<#=method.ReturnType.PythonTypeName#>':
<#+
		this.PushIndent(Constants.IndentString);
		this.WritePlaceHolderContent(type.Name + "_" + method.Name, existingFileContent);
		this.PopIndent();
#>
    return <#=method.ReturnType.PythonTypeName#>(self.context, <#=Constants.MemberFullNames.CreateIndexerObjectPath#>(self.context, self, <#=BuildMethodParameterValueArray(method)#>))
<#+
	}

	private void WriteNewObject(ClientCallableTypeInfo type)
	{
#>
@staticmethod
def newObject(context: -> <#=Constants.TypeFullNames.ClientRequestContext#>): <#=type.ClientType.TypeScriptTypeName#> {
		var ret = new <#=type.ClientType.TypeScriptTypeName#>(context, <#=Constants.MemberFullNames.CreateNewObjectObjectPath#>(context, "<#=type.FullName#>", <#=Utility.GetBooleanLiteral(type.ClientType.IsClientObjectCollection)#> /*isCollection*/));
		return ret;
	} 
<#+
	}

	private string BuildMethodParameterList(ClientCallableMethodInfo method)
	{
		StringBuilder sb = new StringBuilder();
		sb.Append("self");
		for (int i = 0; i < method.Parameters.Count; i++)
		{
			ClientCallableParameterInfo param = method.Parameters[i];
			sb.Append(", ");

			sb.Append(param.Name);
			sb.Append(" -> ");
			sb.Append("'");
			sb.Append(param.ParameterType.PythonTypeName);
			sb.Append("'");
		}

		return sb.ToString();
	}

	private string BuildMethodParameterValueArray(ClientCallableMethodInfo method)
	{
		StringBuilder sb = new StringBuilder();
		sb.Append("[");
		for (int i = 0; i < method.Parameters.Count; i++)
		{
			if (i != 0)
			{
				sb.Append(", ");
			}

			sb.Append(method.Parameters[i].Name);
		}

		sb.Append("]");
		return sb.ToString();
	}

	private void WriteHandleResult(ClientCallableTypeInfo type)
	{
#>
	/** Handle results returned from the document
	 * @private
	 */
	_handleResult(value: any): void {
		if (<#=Constants.MemberFullNames.IsNullOrUndefined#>(value))
			return;
		var obj: Object = value;
		<#=Constants.MemberFullNames.FixObjectPathIfNecessary#>(this, obj);
<#+
		foreach(ClientCallablePropertyInfo prop in type.ScalarProperties.Where(p => !p.ExcludedFromClientLibrary))
		{
#>
		if (!<#=Constants.MemberFullNames.IsUndefined#>(obj["<#=prop.Name#>"])){
			this.<#=prop.FieldName#> = obj["<#=prop.Name#>"];
		}

<#+
		}

		List<string> navPropNames = new List<string>();
		foreach (ClientCallablePropertyInfo prop in type.ObjectProperties.Where(p => !p.IsVolatile && !p.ExcludedFromClientLibrary))
		{
			navPropNames.Add("\"" + Utility.ToCamelLowerCase(prop.Name) + "\"");
			navPropNames.Add("\"" + prop.Name + "\"");
		}

		if (navPropNames.Count > 0)
		{
#>
		<#=Constants.MemberFullNames.HandleNavigationPropertyResults#>(this, obj, [<#=String.Join(", ", navPropNames.ToArray())#>]);
<#+	
		}

		if (type.ClientType.ChildItemClientType != null && type.ClientType.ChildItemClientType.IsClientObject)
		{
			bool hasIndexerMethod = (type.Methods.FirstOrDefault(m => m.IsIndexerMethod) != null);
#>
		if (!<#=Constants.MemberFullNames.IsNullOrUndefined#>(obj[OfficeExtension.Constants.items])){
			this.m__items = [];
			var _data: Array<any> = <Array<any>> obj[OfficeExtension.Constants.items];
			for (var i = 0; i < _data.length; i++)
			{
				var _item: <#=type.ClientType.ChildItemClientType.TypeScriptTypeName#> = new <#=type.ClientType.ChildItemClientType.TypeScriptTypeName#>(this.context, <#=Constants.MemberFullNames.CreateChildItemObjectPathUsingIndexerOrGetItemAt#>(<#=Utility.GetBooleanLiteral(hasIndexerMethod)#>, this.context, this, _data[i], i));
				_item._handleResult(_data[i]);
				this.m__items.push(_item);
			}
		}
<#+
		}
#>
	}
<#+
	}

	private void WriteInitReferenceIdMethod(ClientCallableTypeInfo type)
	{
		ClientCallablePropertyInfo prop = type.ScalarProperties.FirstOrDefault(p => p.Name == Constants.MemberNames.ReferenceId);
		if (!type.IsValueObject && prop != null)
		{
#>
	_initReferenceId(value: string): void {
		this.<#=prop.FieldName#> = value;
	}
<#+
		}
	}

	private void WriteLoadMethod(ClientCallableTypeInfo type)
	{
		if (!type.IsValueObject)
		{
			// Only add a "load" method on objects that have properties or are collections.
			// Otherwise, for something like the Excel "Functions" object, since it's just a namespace placeholder object
			// with no actual properties on it, having "load" is only confusing.
			if (type.Properties.Any() || (type.ClientType.ChildItemClientType != null)) {
				var clientTypeOrCustomTypescriptName = string.IsNullOrEmpty(type.CustomTypeScriptTypeName) ? type.ClientType.TypeScriptTypeName : type.CustomTypeScriptTypeName;
#>

	/**
	 * Queues up a command to load the specified properties of the object. You must call "context.sync()" before reading the properties.
	 */
	load(option?: string|string[]|OfficeExtension.LoadOption): <#= clientTypeOrCustomTypescriptName #> {
		<#=Constants.MemberFullNames.Load#>(this, option);
		return this;
	}
<#+
			}
		}
	}

	private void WriteClientValueObjectType(ClientCallableTypeInfo type, XDocument xdoc, string[] existingFileContent)
	{
#>
export interface <#=type.Name#> {
<#+
		WriteClientValueObjectTypeFields(type, xdoc);
		this.WriteLine(string.Empty);
		this.PushIndent(Constants.IndentString);
		this.WritePlaceHolderContent(type.Name + "_Custom_Members", existingFileContent);
		this.PopIndent();
#>
}
<#+
	}

	private void WriteClientValueObjectTypeFields(ClientCallableTypeInfo type, XDocument xdoc)
	{
		foreach (ClientCallablePropertyInfo prop in type.Properties.Where(p => !p.ExcludedFromClientLibrary))
		{
			this.PushIndent(Constants.IndentString);
			this.WriteComments(Utility.BuildJsDocForProperty(type, prop, xdoc));
			this.PopIndent();
			string optional = "";
			if (prop.IsOptional)
			{
				optional = "?";
			}
#>
	<#=Utility.ToCamelLowerCase(prop.Name)#><#=optional#> : <#=prop.PropertyType.TypeScriptTypeName#>;
<#+
		}
	}

	private void WriteComments(IEnumerable<string> comments)
	{
		if (comments != null)
		{
			foreach (string line in comments)
			{
				this.WriteLine(line);
			}
		}
	}
#>
