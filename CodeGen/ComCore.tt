<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Globalization" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="Helper.tt" #>
<#@ include file="Core.tt" #>
<#@ output extension=".txt" #>

<#+
	void WriteComFiles()
	{
		LaunchDebuggerIfNecessary();
		if (this.CheckInputParameters())
		{
			AssemblyReader assemblyReader = new AssemblyReader(this.InputFilePath, null, this.ReferencedAssemblyPaths, this.MaxVersion);
			assemblyReader.Process();

			CodeGenTemplateFileManager templateFileManager = new CodeGenTemplateFileManager(this.GenerationEnvironment);
			templateFileManager.StartHeader();
#>
/*
 * This is a generated file. <#=this.CreatedByToolStatement#>
 * If there are content placeholders, only edit content inside content placeholders.
 * If there are no content placeholders, do not edit this file directly.
 */
 <#+
			templateFileManager.EndBlock();

			templateFileManager.StartNewFile(this.FileBaseName + "_i" + this.FileNamePostfix + ".cpp");
			this.WriteComConstants(assemblyReader);
			templateFileManager.EndBlock();

			templateFileManager.StartNewFile(this.FileBaseName + "_i" + this.FileNamePostfix + ".h");
			this.WriteComInterfaces(assemblyReader, System.IO.Path.Combine(this.OutputDirectory, this.FileBaseName + "_i" + this.FileNamePostfix + ".h"));
			templateFileManager.EndBlock();

			templateFileManager.StartNewFile(this.FileBaseName + this.FileNamePostfix + ".h");
			this.WriteCoClassHeader(assemblyReader, System.IO.Path.Combine(this.OutputDirectory, this.FileBaseName + this.FileNamePostfix + ".h"));
			templateFileManager.EndBlock();

			templateFileManager.StartNewFile(this.FileBaseName + this.FileNamePostfix + ".idl");
			this.WriteComIdl(assemblyReader);
			templateFileManager.EndBlock();

			foreach(ClientCallableTypeInfo type in assemblyReader.Types.Where(t => !t.IsEnum && t.ComType != null && !string.IsNullOrEmpty(t.ComType.CoClassName)))
			{
				templateFileManager.StartNewFile(type.ComType.CoClassName + ".disp" + this.FileNamePostfix + ".cpp");
				WriteTypeDispatch(type, System.IO.Path.Combine(this.OutputDirectory, type.ComType.CoClassName + ".disp" + this.FileNamePostfix + ".cpp"));
				templateFileManager.EndBlock();
			}

			templateFileManager.StartNewFile("Utility" + this.FileNamePostfix + ".cpp");
			this.WriteUtilityClass(System.IO.Path.Combine(this.OutputDirectory, "Utility" + this.FileNamePostfix + ".cpp"));
			templateFileManager.EndBlock();

			string richApiHostFileName = this.RichApiHostClassName + ".CreateInstance" + this.FileNamePostfix + ".cpp";
			templateFileManager.StartNewFile(richApiHostFileName);
			this.WriteHostCreateInstance(assemblyReader, System.IO.Path.Combine(this.OutputDirectory, richApiHostFileName));
			templateFileManager.EndBlock();

			templateFileManager.WriteTo(this.OutputDirectory, this.CheckoutCommandPrefix);
		}
	}

	void WriteComConstants(AssemblyReader assemblyReader)
	{
		this.WritePreIncludes();
#>
#include <objbase.h>
#include <initguid.h>

<#+
		List<string> namespaceStack = new List<string>();
		foreach (ClientCallableTypeInfo type in assemblyReader.Types.Where(t => t.ComType != null))
		{
			this.EnsureNamespace(namespaceStack, type.ComType.InterfaceNamespace, forTypeScript: false, indentString: Constants.IndentString);
			if (!string.IsNullOrEmpty(type.ComType.InterfaceId))
			{
				this.WriteLine(Utility.BuildDefineGuid(new Guid(type.ComType.InterfaceId), type.ComType.Name, isInterfaceId: true));
			}
			if (!string.IsNullOrEmpty(type.ComType.CoClassId))
			{
				this.WriteLine(Utility.BuildDefineGuid(new Guid(type.ComType.CoClassId), type.ComType.CoClassName, isInterfaceId: false));
			}
		}

		this.EnsureNamespace(namespaceStack, string.Empty, forTypeScript: false, indentString: Constants.IndentString);
	}

	void WriteComInterfaces(AssemblyReader assemblyReader, string existingFilePath)
	{
#>
#pragma once
#include <objbase.h>
<#+
		string[] existingFileContent = this.GetExistingFileContent(existingFilePath);
		this.WriteLine(string.Empty);
		this.WritePlaceHolderContent("GlobalHeader", existingFileContent);
		this.WriteLine(string.Empty);

		List<string> namespaceStack = new List<string>();

		foreach (ClientCallableTypeInfo type in assemblyReader.Types.Where(t => t.ComType != null))
		{
			this.EnsureNamespace(namespaceStack, type.ComType.InterfaceNamespace, forTypeScript: false, indentString: Constants.IndentString);
			if (!string.IsNullOrEmpty(type.ComType.InterfaceId))
			{
				this.WriteLine(Utility.BuildDefineGuid(new Guid(type.ComType.InterfaceId), type.ComType.Name, isInterfaceId: true));
			}
			if (!string.IsNullOrEmpty(type.ComType.CoClassId))
			{
				this.WriteLine(Utility.BuildDefineGuid(new Guid(type.ComType.CoClassId), type.ComType.CoClassName, isInterfaceId: false));
			}
		}

		this.WriteLine(string.Empty);

		foreach (ClientCallableTypeInfo type in assemblyReader.Types.Where(t => t.ComType != null))
		{
			this.EnsureNamespace(namespaceStack, type.ComType.InterfaceNamespace, forTypeScript: false, indentString: Constants.IndentString);
			if (!string.IsNullOrEmpty(type.ComType.Name))
			{
#>
class <#=type.ComType.Name#>;
<#+
			}
		}

		foreach (ClientCallableTypeInfo type in assemblyReader.Types.Where(t => t.IsEnum))
		{
			this.EnsureNamespace(namespaceStack, type.ComInterfaceNamespace, forTypeScript: false, indentString: Constants.IndentString);
#>
enum class <#=type.Name#> : int
{
<#+
			foreach (KeyValuePair<string, int> field in type.EnumFields)
			{

#>
	<#=field.Key#> = <#=field.Value#>,
<#+
			}
#>
};
<#+
		}

		this.WriteLine(string.Empty);

		foreach (ClientCallableTypeInfo type in assemblyReader.Types.Where(t => t.ComType != null))
		{
			this.EnsureNamespace(namespaceStack, type.ComType.InterfaceNamespace, forTypeScript: false, indentString: Constants.IndentString);
			this.WriteLine(string.Empty);
			WriteComInterfaceType(type);
		}

		this.EnsureNamespace(namespaceStack, string.Empty, forTypeScript: false, indentString: Constants.IndentString);

		this.WriteLine(string.Empty);
		this.WritePlaceHolderContent("GlobalFooter", existingFileContent);
		this.WriteLine(string.Empty);
	}

	private void WriteComInterfaceType(ClientCallableTypeInfo type)
	{
#>
class DECLSPEC_NOVTABLE <#=type.ComType.Name#>: public IDispatch
{
public:
<#+
		PushIndent(Constants.IndentString);
		foreach (ClientCallableMemberInfo member in type.ComMembers)
		{
			WriteComInterfaceMember(member);
		}

		if (type.ComType.SupportEnumeration)
		{
#>
STDMETHOD(get__NewEnum)(IEnumVARIANT** ppEnum) MSONOTHROW = 0;
<#+
		}
		PopIndent();
#>
};
<#+
	}

	private void WriteComInterfaceMember(ClientCallableMemberInfo member)
	{
		if (member.ComDispatchPropertyGetMethod != null)
		{
			WriteComInterfaceMethod(member.ComDispatchPropertyGetMethod);
		}
		if (member.ComDispatchPropertySetMethod != null)
		{
			WriteComInterfaceMethod(member.ComDispatchPropertySetMethod);
		}
		if (member.ComDispatchMethodMethod != null)
		{
			WriteComInterfaceMethod(member.ComDispatchMethodMethod);
		}
	}

	private void WriteComInterfaceMethod(ClientCallableMethodInfo method)
	{
#>
STDMETHOD(<#=method.ComMember.Name#>)(<#=Utility.BuildMethodArgumentListForCom(method)#>) MSONOTHROW = 0;
<#+
	}


	void WriteCoClassHeader(AssemblyReader assemblyReader, string existingHeaderFilePath)
	{
#>
#pragma once
#include <objbase.h>
#include "<#=this.FileBaseName#>_i<#=this.FileNamePostfix#>.h"
#include <RichApi.h>
#include <RichApiIDispatchMacro.h>
<#+
		this.WriteIncludes();

		string[] existingFileContent;
		if (File.Exists(existingHeaderFilePath))
		{
			existingFileContent = File.ReadAllLines(existingHeaderFilePath);
		}
		else
		{
			existingFileContent = new string[0];
		}

		this.WriteLine(string.Empty);
		this.WritePlaceHolderContent("GlobalHeader", existingFileContent);
		this.WriteLine(string.Empty);

		List<string> namespaceStack = new List<string>();

		foreach (ClientCallableTypeInfo type in assemblyReader.Types.Where(t => t.ComType != null))
		{
			this.EnsureNamespace(namespaceStack, type.ComType.CoClassNamespace, forTypeScript: false, indentString: Constants.IndentString);
			if (!string.IsNullOrEmpty(type.ComType.CoClassName))
			{
#>
class <#=type.ComType.CoClassName#>;
<#+
			}
		}

		this.WriteLine(string.Empty);

		foreach (ClientCallableTypeInfo type in assemblyReader.Types.Where(t => t.ComType != null && !string.IsNullOrEmpty(t.ComType.CoClassName)))
		{
			this.EnsureNamespace(namespaceStack, type.ComType.CoClassNamespace, forTypeScript: false, indentString: Constants.IndentString);
			this.WriteLine(string.Empty);
			WriteCoClassHeaderType(type, existingFileContent);
		}

		this.EnsureNamespace(namespaceStack, this.ImplNamespace, forTypeScript: false, indentString: Constants.IndentString);
		this.WriteLine(string.Empty);
		this.WritePlaceHolderContent("UtilityClassHeader", existingFileContent);
#>
class Utility
{
public:
	static HRESULT GetArgument(const ::DISPPARAMS* pDispParams, UINT index, VARTYPE vt, /*out*/ Mso::VariantHolder& varOut) MSONOTHROW;
<#+
		PushIndent(Constants.IndentString);
		this.WritePlaceHolderContent("Utility_ExtraFunctions", existingFileContent);
		this.WriteLine(string.Empty);
		PopIndent();
#>
private:
	Utility();
};
<#+
		this.EnsureNamespace(namespaceStack, string.Empty, forTypeScript: false, indentString: Constants.IndentString);
		this.WriteLine(string.Empty);
		this.WritePlaceHolderContent("GlobalFooter", existingFileContent);
		this.WriteLine(string.Empty);
	}

	private void WriteCoClassHeaderType(ClientCallableTypeInfo type, string[] existingFileContent)
	{
		this.WriteLine(string.Empty);
		this.WritePlaceHolderContent(type.ComType.CoClassName + "ClassHeader", existingFileContent);
#>
class <#=type.ComType.CoClassName#>: public <#=type.ComType.InterfaceNamespace#>::<#=type.ComType.Name#>
	, public OfficeExtension::ServerRuntime::IRichApiTypeInfo
<#+
		if (type.ComType.SupportIEnumVARIANT)
		{
#>
	, public IEnumVARIANT
<#+
		}
		if (!string.IsNullOrEmpty(this.BaseClass))
		{
#>
	, public <#=this.BaseClass#>
<#+
		}
		if (!string.IsNullOrEmpty(this.MsoDebugMethodMacroStart))
		{
#>
#ifdef DEBUG
	, public IMsoDebugMessage
#endif
<#+
		}
		PushIndent(Constants.IndentString);
		this.WritePlaceHolderContent(type.ComType.CoClassName + "BaseClass", existingFileContent);
		PopIndent();
#>
{
public:
<#+
		PushIndent(Constants.IndentString);
		this.WritePlaceHolderContent(type.ComType.CoClassName + "Constructor", existingFileContent);
		this.WriteLine(string.Empty);
		PopIndent();
#>
	virtual ~<#=type.ComType.CoClassName#>() MSONOTHROW;
<#+
		PushIndent(Constants.IndentString);
		this.WriteLine(string.Empty);
		this.WritePlaceHolderContent(type.ComType.CoClassName + "Public", existingFileContent);
		this.WriteLine(string.Empty);
		foreach (ClientCallableMemberInfo member in type.ComMembers)
		{
			WriteCoClassHeaderMember(member);
		}

		if (type.ComType.SupportEnumeration)
		{
#>
STDMETHODIMP get__NewEnum(IEnumVARIANT** ppEnum) MSONOTHROW override;
<#+
		}
		if (type.ComType.SupportIEnumVARIANT)
		{
#>
STDMETHODIMP Next(ULONG celt, VARIANT *rgelt, ULONG *pceltFetched) MSONOTHROW override;
STDMETHODIMP Skip(ULONG celt) MSONOTHROW override;
STDMETHODIMP Reset() MSONOTHROW override;
STDMETHODIMP Clone(IEnumVARIANT **ppEnum) MSONOTHROW override;
<#+
		}
		PopIndent();
#>

public:
	RICHAPI_DECLARE_COM_IDISPATCH
	typedef <#=type.ComType.InterfaceNamespace#>::<#=type.ComType.Name#> RichApiInterfaceType;
	
	STDMETHODIMP GetRichApiInterfaceId(IID* pInterfaceId) MSONOTHROW override;
	static STDMETHODIMP GetClassRichApiInterfaceId(IID* pInterfaceId) MSONOTHROW;

<#+
		if (!string.IsNullOrEmpty(this.MsoDebugMethodMacroStart))
		{
#>
#if DEBUG
	MSOOVERRIDEDEBUGMETHOD2;
#endif
<#+	
		}
#>
private:
<#+
		PushIndent(Constants.IndentString);
		foreach (ClientCallableMemberInfo member in type.ComMembers)
		{
			WriteCoClassHeaderMemberInvokeHelper(member);
		}

		if (type.ComType.SupportEnumeration)
		{	
#>
HRESULT get__NewEnumInvoke(const ::DISPPARAMS* pDispParams, VARIANT* pVarResult) MSONOTHROW;
<#+
		}
		PopIndent();
#>

private:
	Mso::TInited<LONG> m_cRef;
<#+
		PushIndent(Constants.IndentString);
		this.WriteLine(string.Empty);
		this.WritePlaceHolderContent(type.ComType.CoClassName + "Private", existingFileContent);
		PopIndent();
#>
};
<#+
	}

	private void WriteCoClassHeaderMember(ClientCallableMemberInfo member)
	{
		if (member.ComDispatchPropertyGetMethod != null)
		{
			WriteCoClassHeaderMethod(member.ComDispatchPropertyGetMethod);
		}
		if (member.ComDispatchPropertySetMethod != null)
		{
			WriteCoClassHeaderMethod(member.ComDispatchPropertySetMethod);
		}
		if (member.ComDispatchMethodMethod != null)
		{
			WriteCoClassHeaderMethod(member.ComDispatchMethodMethod);
		}
	}

	private void WriteCoClassHeaderMethod(ClientCallableMethodInfo method)
	{
#>
STDMETHODIMP <#=method.ComMember.Name#>(<#=Utility.BuildMethodArgumentListForCom(method)#>) MSONOTHROW override;
<#+
	}

	private void WriteCoClassHeaderMemberInvokeHelper(ClientCallableMemberInfo member)
	{
		if (member.ComDispatchPropertyGetMethod != null)
		{
			WriteCoClassHeaderMethodInvokeHelper(member.ComDispatchPropertyGetMethod);
		}
		if (member.ComDispatchPropertySetMethod != null)
		{
			WriteCoClassHeaderMethodInvokeHelper(member.ComDispatchPropertySetMethod);
		}
		if (member.ComDispatchMethodMethod != null)
		{
			WriteCoClassHeaderMethodInvokeHelper(member.ComDispatchMethodMethod);
		}
	}

	private void WriteCoClassHeaderMethodInvokeHelper(ClientCallableMethodInfo method)
	{
#>
HRESULT <#=method.ComMember.Name#>Invoke(const ::DISPPARAMS* pDispParams, VARIANT* pVarResult) MSONOTHROW;
<#+
	}

	void WriteComIdl(AssemblyReader assemblyReader)
	{
#>
import "oaidl.idl";
import "ocidl.idl";
<#+
		foreach (ClientCallableTypeInfo type in assemblyReader.Types.Where(t => t.ComType != null))
		{
			if (!string.IsNullOrEmpty(type.ComType.Name))
			{
#>
interface <#=type.ComType.Name#>;
<#+						
			}
		}

		this.WriteLine(string.Empty);
		foreach (ClientCallableTypeInfo type in assemblyReader.Types.Where(t => t.IsEnum))
		{
#>
enum <#=type.Name#>
{
<#+
			foreach (KeyValuePair<string, int> field in type.EnumFields)
			{

#>
	<#=type.Name#>_<#=field.Key#> = <#=field.Value#>,
<#+
			}
#>
};
<#+
		}

		this.WriteLine(string.Empty);
		foreach (ClientCallableTypeInfo type in assemblyReader.Types.Where(t => t.ComType != null))
		{
			WriteComIdlType(type);
		}

		this.WriteLine(string.Empty);
		WriteComIdlLibrary(assemblyReader);
	}

	private void WriteComIdlType(ClientCallableTypeInfo type)
	{
#>

[
	object,
	uuid(<#=type.InterfaceId.ToString("D")#>)
]
interface <#=type.ComType.Name#>: IDispatch
{
<#+
		PushIndent(Constants.IndentString);
		foreach (ClientCallableMemberInfo member in type.ComMembers)
		{
			ClientCallablePropertyInfo prop = member as ClientCallablePropertyInfo;
			if (prop != null)
			{
				WriteComIdlProperty(prop);
			}
			else
			{
				WriteComIdlMethod((ClientCallableMethodInfo)member);
			}
		}

		if (type.ComType.SupportEnumeration)
		{
#>
[propget, restricted, id(DISPID_NEWENUM)]
HRESULT _NewEnum([out, retval] IEnumVARIANT** ppEnum);
<#+
		}
		PopIndent();
#>
};
<#+
	}

	private void WriteComIdlProperty(ClientCallablePropertyInfo prop)
	{
#>
[propget, id(<#=prop.ComMember.DispatchId.ToString(CultureInfo.InvariantCulture)#>)]
HRESULT <#=prop.ComMember.Name#>([out, retval] <#=Utility.GetTypeDeclarationNameForCom(prop.PropertyType, forIdl: true)#>* pValue);
<#+
		if (!prop.IsReadonly)
		{
#>
[propput, id(<#=prop.ComMember.DispatchId.ToString(CultureInfo.InvariantCulture)#>)]
HRESULT <#=prop.ComMember.Name#>([in] <#=Utility.GetTypeDeclarationNameForCom(prop.PropertyType, forIdl: true)#> pValue);
<#+
		}
	}

	private void WriteComIdlMethod(ClientCallableMethodInfo method)
	{
		string memberType = "";
		if (method.ComMember.DispatchFlag == Constants.DISPATCH_PROPERTYGET)
		{
			memberType = "propget, ";
		}
		else if (method.ComMember.DispatchFlag == Constants.DISPATCH_PROPERTYPUT)
		{
			memberType = "propput, ";
		}
#>
[<#=memberType#>id(<#=method.ComMember.DispatchId.ToString(CultureInfo.InvariantCulture)#>)]
HRESULT <#=method.ComMember.Name#>(<#=Utility.BuildMethodArgumentListForCom(method, forIdl:true)#>);
<#+
	}

	private void WriteComIdlLibrary(AssemblyReader reader)
	{
#>

[
	uuid(<#=reader.AssemblyId.ToString("D")#>),
	version(1.0)
]
library <#=this.FileBaseName#>Library
{
	importlib("stdole2.tlb");
<#+
		foreach (ClientCallableTypeInfo type in reader.Types.Where(t => t.ComType != null))
		{
			if (!string.IsNullOrEmpty(type.ComType.CoClassId) && 
				!string.IsNullOrEmpty(type.ComType.CoClassName))
			{
#>
	[
		uuid(<#=new Guid(type.ComType.CoClassId).ToString("D")#>)
	]
	coclass <#=type.ComType.CoClassName#>
	{
		[default] interface <#=type.ComType.Name#>;
	};

<#+
			}
		}
#>
};
<#+
	}

	private void WritePreIncludes()
	{
		foreach(string preinclude in this.AdditionalPreIncludes)
		{
#>
#include "<#=preinclude#>"
<#+
		}
	}

	private void WriteIncludes()
	{
		foreach(string include in this.AdditionalIncludes)
		{
#>
#include "<#=include#>"
<#+
		}
	}

	private void WriteTypeDispatch(ClientCallableTypeInfo type, string existingFilePath)
	{
		this.WritePreIncludes();
		string[] existingFileContent = this.GetExistingFileContent(existingFilePath);
#>
#include <objbase.h>
<#+
		this.WriteIncludes();
#>
#include "<#=this.FileBaseName#>_i<#=this.FileNamePostfix#>.h"
#include "<#=this.FileBaseName#><#=this.FileNamePostfix#>.h"
<#+
		this.WriteLine(string.Empty);
		this.WritePlaceHolderContent("GlobalHeader", existingFileContent);
		this.WriteLine(string.Empty);

		this.WriteDispIdDefine(type);
		List<string> namespaceStack = new List<string>();
		this.EnsureNamespace(namespaceStack, type.ComType.CoClassNamespace, forTypeScript: false, indentString: Constants.IndentString);
		this.WriteGetIdsOfNames(type, existingFileContent);
		this.WriteLine(string.Empty);
		this.WriteInvoke(type, existingFileContent);
		this.WriteLine(string.Empty);
		this.WriteInvokeHelpers(type, existingFileContent);
		if (!string.IsNullOrEmpty(this.MsoDebugMethodMacroStart))
		{
#>

#ifdef DEBUG
<#=this.MsoDebugMethodMacroStart#>(<#=type.ComType.CoClassName#>)
<#+
		this.WritePlaceHolderContent("DebugMethodBody", existingFileContent);
#>
IMPLEMENT_MSO_DEBUGMETHOD_END
#endif

<#+
		}
#>

/*static*/ STDMETHODIMP <#=type.ComType.CoClassName#>::GetClassRichApiInterfaceId(IID* pInterfaceId) MSONOTHROW
{
	*pInterfaceId = <#=type.ComType.InterfaceNamespace#>::IID_<#=type.ComType.Name#>;
	return S_OK;
}

STDMETHODIMP <#=type.ComType.CoClassName#>::GetRichApiInterfaceId(IID* pInterfaceId) MSONOTHROW
{
	return GetClassRichApiInterfaceId(pInterfaceId);
}

<#+	
		if (string.IsNullOrEmpty(this.CustomDeleter))
		{
#>
IMPLEMENT_MSO_IUNKNOWN_REFCOUNT_HEAP(<#=type.ComType.CoClassName#>)
<#+
		}
		else
		{
#>
IMPLEMENT_MSO_IUNKNOWN_REFCOUNT_HEAP_DELETER(<#=type.ComType.CoClassName#>, <#=this.CustomDeleter#>)
<#+
		}
#>
IMPLEMENT_MSO_IUNKNOWN_QI_START(<#=type.ComType.CoClassName#>, <#=type.ComType.InterfaceNamespace#>::<#=type.ComType.Name#>)
	EXPOSE_INTERFACE(IID_IDispatch, IDispatch)
	EXPOSE_INTERFACE(<#=type.ComType.InterfaceNamespace#>::IID_<#=type.ComType.Name#>, <#=type.ComType.InterfaceNamespace#>::<#=type.ComType.Name#>)
	EXPOSE_INTERFACE(OfficeExtension::ServerRuntime::IID_IRichApiTypeInfo, OfficeExtension::ServerRuntime::IRichApiTypeInfo)
<#+
		if (type.ComType.SupportIEnumVARIANT)
		{
#>
	EXPOSE_INTERFACE_(IEnumVARIANT)
<#+
		}
		this.WritePlaceHolderContent("ExposeInterface", existingFileContent);
		if (!string.IsNullOrEmpty(this.MsoDebugMethodMacroStart))
		{
#>
#ifdef DEBUG
	EXPOSE_INTERFACE_(IMsoDebugMessage)
#endif
<#+
		}
#>
IMPLEMENT_MSO_IUNKNOWN_END

RICHAPI_IMPLEMENT_COM_IDISPATCH_EMPTYTYPEINFO(<#=type.ComType.CoClassName#>)

<#+
		this.EnsureNamespace(namespaceStack, string.Empty, forTypeScript: false, indentString: Constants.IndentString);

		this.WriteLine(string.Empty);
		this.WritePlaceHolderContent("GlobalFooter", existingFileContent);
		this.WriteLine(string.Empty);
	}

	private void WriteDispIdDefine(ClientCallableTypeInfo type)
	{
		foreach (ClientCallableMemberInfo member in type.ComMembers)
		{
#>
#define DISPID_<#=type.ComType.Name#>_<#=member.ComMember.Name#> <#=member.ComMember.DispatchId.ToString(CultureInfo.InvariantCulture)#>
<#+
		}
	}

	private void WriteGetIdsOfNames(ClientCallableTypeInfo type, string[] existingFileContent)
	{
		string tagMarker, tagMethodSuffixIfTagged, tagValueIfTagged;
#>
STDMETHODIMP <#=type.ComType.CoClassName#>::GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames, LCID lcid, DISPID *rgDispId) MSONOTHROW
{
	UNREFERENCED_PARAMETER(riid);
	UNREFERENCED_PARAMETER(lcid);
	if (rgszNames == nullptr)
	{
<#+
		this.GetTagMarker(existingFileContent, "GetIdsOfNamesRgsznames", out tagMarker, out tagMethodSuffixIfTagged, out tagValueIfTagged);
#>
		<#=this.SetHrRet#><#=tagMethodSuffixIfTagged#>(E_INVALIDARG<#=tagValueIfTagged#>);<#=tagMarker#>
	}
	
	if (*rgszNames == nullptr)
	{
<#+
		this.GetTagMarker(existingFileContent, "GetIdsOfNamesRgsznames2", out tagMarker, out tagMethodSuffixIfTagged, out tagValueIfTagged);
#>
		<#=this.SetHrRet#><#=tagMethodSuffixIfTagged#>(E_INVALIDARG<#=tagValueIfTagged#>);<#=tagMarker#>
	}

	if (cNames != 1)
	{
<#+
		this.GetTagMarker(existingFileContent, "GetIdsOfNamesCNames", out tagMarker, out tagMethodSuffixIfTagged, out tagValueIfTagged);
#>
		<#=this.SetHrRet#><#=tagMethodSuffixIfTagged#>(E_INVALIDARG<#=tagValueIfTagged#>);<#=tagMarker#>
	}

<#+
		foreach (ClientCallableMemberInfo member in type.ComMembers)
		{
#>
	if (_wcsicmp(*rgszNames, L"<#=member.ComMember.Name#>") == 0)
	{
		*rgDispId = DISPID_<#=type.ComType.Name#>_<#=member.ComMember.Name#>;
		return S_OK;
	}
<#+
		}
#>
<#+
		PushIndent(Constants.IndentString);
		this.WritePlaceHolderContent(type.ComType.CoClassName + "GetIDsOfNames_Final", existingFileContent);
		PopIndent();
		this.GetTagMarker(existingFileContent, "GetIdsOfNamesUnknownName", out tagMarker, out tagMethodSuffixIfTagged, out tagValueIfTagged);
#>
	<#=this.SetHrRet#><#=tagMethodSuffixIfTagged#>(DISP_E_UNKNOWNNAME<#=tagValueIfTagged#>);<#=tagMarker#>
}
<#+
	}

	private string BuildInvokeHelperStatement(ClientCallableTypeInfo type, ClientCallableMethodInfo method, string[] existingFileContent)
	{
		string tagMarker, tagMethodSuffixIfTagged, tagValueIfTagged;
		this.GetTagMarker(existingFileContent, method.ComMember.Name + "_Invoke", out tagMarker, out tagMethodSuffixIfTagged, out tagValueIfTagged);
		return this.SetHrRet + tagMethodSuffixIfTagged + "(" + method.ComMember.Name + "Invoke(pDispParams, pVarResult)" + tagValueIfTagged + ");" + tagMarker;
	}

	private void WriteInvoke(ClientCallableTypeInfo type, string[] existingFileContent)
	{
		string tagMarker, tagMethodSuffixIfTagged, tagValueIfTagged;
#>
STDMETHODIMP <#=type.ComType.CoClassName#>::Invoke(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags, ::DISPPARAMS* pDispParams, VARIANT* pVarResult, ::EXCEPINFO* pExcepInfo, UINT* puArgErr) MSONOTHROW
{
	UNREFERENCED_PARAMETER(riid);
	UNREFERENCED_PARAMETER(lcid);
	UNREFERENCED_PARAMETER(pExcepInfo);
	UNREFERENCED_PARAMETER(puArgErr);
	if (pVarResult)
	{
		VariantInit(pVarResult);
	}

	switch (dispIdMember)
	{
<#+
		foreach (ClientCallableMemberInfo member in type.ComMembers)
		{
			string invokePropertyGet = null;
			string invokePropertySet = null;
			string invokeMethod = null;

			if (member.ComDispatchPropertyGetMethod != null)
			{
				invokePropertyGet = this.BuildInvokeHelperStatement(type, member.ComDispatchPropertyGetMethod, existingFileContent);
			}

			if (member.ComDispatchPropertySetMethod != null)
			{
				invokePropertySet = this.BuildInvokeHelperStatement(type, member.ComDispatchPropertySetMethod, existingFileContent);
			}

			if (member.ComDispatchMethodMethod != null)
			{
				invokeMethod = this.BuildInvokeHelperStatement(type, member.ComDispatchMethodMethod, existingFileContent);
			}
			
#>
		case DISPID_<#=type.ComType.Name#>_<#=member.ComMember.Name#>:
<#+
			if (invokePropertyGet != null)
			{
#>
			if (wFlags & DISPATCH_PROPERTYGET)
			{
				<#=invokePropertyGet#>
			}

<#+
			}

			if (invokePropertySet != null)
			{
#>
			if (wFlags & DISPATCH_PROPERTYPUT)
			{
				<#=invokePropertySet#>
			}

<#+
			}

			if (invokeMethod != null)
			{
#>
			if (wFlags & DISPATCH_METHOD)
			{
				<#=invokeMethod#>
			}

<#+
			}
#>
			break;
<#+
		}

		if (type.ComType.SupportEnumeration)
		{
			this.GetTagMarker(existingFileContent, "_NewEnum_Invoke", out tagMarker, out tagMethodSuffixIfTagged, out tagValueIfTagged);
#>
		case DISPID_NEWENUM:
			if (wFlags & DISPATCH_PROPERTYGET)
			{
				<#=this.SetHrRet#><#=tagMethodSuffixIfTagged#>(get__NewEnumInvoke(pDispParams, pVarResult)<#=tagValueIfTagged#>);<#=tagMarker#>
			}
			break;
<#+
		}
#>
		default:
<#+
			PushIndent(Constants.IndentString);
			PushIndent(Constants.IndentString);
			PushIndent(Constants.IndentString);
			this.WritePlaceHolderContent(type.ComType.CoClassName + "Invoke_Default", existingFileContent);
			PopIndent();
			PopIndent();
			PopIndent();
#>
			break;
	}

<#+
		this.GetTagMarker(existingFileContent, "InvokeMemberNotFound", out tagMarker, out tagMethodSuffixIfTagged, out tagValueIfTagged);
#>
	<#=this.SetHrRet#><#=tagMethodSuffixIfTagged#>(DISP_E_MEMBERNOTFOUND<#=tagValueIfTagged#>);<#=tagMarker#>
}
<#+
	}

	void WriteInvokeHelpers(ClientCallableTypeInfo type, string[] existingFileContent)
	{
		foreach (ClientCallableMemberInfo member in type.ComMembers)
		{
			this.WriteLine(string.Empty);

			ClientCallableMethodInfo method;
			method = member.ComDispatchPropertyGetMethod;
			if (method != null)
			{
				WriteInvokeHelperForOneMethod(type, method, existingFileContent);
			}

			method = member.ComDispatchPropertySetMethod;
			if (method != null)
			{
				WriteInvokeHelperForOneMethod(type, method, existingFileContent);
			}

			method = member.ComDispatchMethodMethod;
			if (method != null)
			{
				WriteInvokeHelperForOneMethod(type, method, existingFileContent);
			}
		}

		if (type.ComType.SupportEnumeration)
		{
			string tagMarker, tagMethodSuffixIfTagged, tagValueIfTagged;
			this.GetTagMarker(existingFileContent, "Invoke__NewEnum", out tagMarker, out tagMethodSuffixIfTagged, out tagValueIfTagged);
#>
HRESULT <#=type.ComType.CoClassName#>::get__NewEnumInvoke(const ::DISPPARAMS* pDispParams, VARIANT* pVarResult) MSONOTHROW
{
	UNREFERENCED_PARAMETER(pDispParams);
	if (pVarResult != nullptr)
	{
		VariantInit(pVarResult);
	}
	Mso::TCntPtr<IEnumVARIANT> _ret;
	<#=this.IfFailRet#><#=tagMethodSuffixIfTagged#>(get__NewEnum(_ret.GetAddressOf())<#=tagValueIfTagged#>);<#=tagMarker#>
	if (pVarResult != nullptr)
	{
		pVarResult->vt = VT_UNKNOWN;
		pVarResult->punkVal = _ret.Detach();
	}

	return S_OK;
}
<#+
		}
	}

	string GetArgumentLocalVarName(ClientCallableParameterInfo par)
	{
		return "var" + Utility.ToCamelUpperCase(par.Name);
	}

	string GetArgumentLocalCntPtrName(ClientCallableParameterInfo par)
	{
		return "sp" + Utility.ToCamelUpperCase(par.Name);
	}

	void WriteInvokeHelperForOneMethod(ClientCallableTypeInfo type,  ClientCallableMethodInfo method, string[] existingFileContent)
	{
		string tagMarker, tagMethodSuffixIfTagged, tagValueIfTagged;
#>
HRESULT <#=type.ComType.CoClassName#>::<#=method.ComMember.Name#>Invoke(const ::DISPPARAMS* pDispParams, VARIANT* pVarResult) MSONOTHROW
{
<#+
		if (method.Parameters.Count == 0)
		{
#>
	UNREFERENCED_PARAMETER(pDispParams);
<#+
		}
#>
	if (pVarResult != nullptr)
	{
		VariantInit(pVarResult);
	}

<#+
		foreach (ClientCallableParameterInfo par in method.Parameters)
		{
#>
	Mso::VariantHolder <#=this.GetArgumentLocalVarName(par)#>;
<#+
			if (par.ParameterType.IsClientObject || par.ParameterType.IsClientValueObject)
			{
#>
	Mso::TCntPtr<<#=Utility.GetTypeNameForCom(par.ParameterType)#>> <#=this.GetArgumentLocalCntPtrName(par)#>;
<#+
			}
		}
		string returnValueInitStatement = string.Empty;
		if (!method.ReturnType.IsVoid)
		{
			string retInitStatementFormat = Utility.GetArgumentVariableInitStatementFormat(method.ReturnType);
			returnValueInitStatement = string.Format(CultureInfo.InvariantCulture, retInitStatementFormat, "_ret");
		}

#>
	<#=returnValueInitStatement#>

<#+
		int index = 0;
		int dispParamIndex;

		StringBuilder sbInvokeParameterList = new StringBuilder();
		foreach (ClientCallableParameterInfo par in method.Parameters)
		{
			if (index > 0)
			{
				sbInvokeParameterList.Append(", ");
			}

			if (par.ParameterType.IsClientObject || par.ParameterType.IsClientValueObject)
			{
				sbInvokeParameterList.Append(this.GetArgumentLocalCntPtrName(par));
				sbInvokeParameterList.Append(".Get()");
			}
			else
			{
				if ((par.ParameterType.IsEnum && !par.ParameterType.IsNullable))
				{
					sbInvokeParameterList.Append("(");
					sbInvokeParameterList.Append(Utility.GetTypeDeclarationNameForCom(par.ParameterType));
					sbInvokeParameterList.Append(")");
				}

				sbInvokeParameterList.Append(this.GetArgumentLocalVarName(par));
				if (!par.ParameterType.IsComVariantType)
				{
					sbInvokeParameterList.Append(".");
					sbInvokeParameterList.Append(Utility.GetVariantMemberName(par.ParameterType));
				}
			}
			//  Arguments are stored in pDispParams->rgvarg in reverse order
			dispParamIndex = method.Parameters.Count -1 -index;
			this.GetTagMarker(existingFileContent, "InvokeArg_" + method.ComMember.Name + "_" + par.Name, out tagMarker, out tagMethodSuffixIfTagged, out tagValueIfTagged);
#>
	<#=this.IfFailRet#><#=tagMethodSuffixIfTagged#>(<#=this.ImplNamespace#>::Utility::GetArgument(pDispParams, <#=dispParamIndex.ToString(CultureInfo.InvariantCulture)#>, <#=Utility.GetVariantVarType(par.ParameterType)#>, /*out*/ <#=this.GetArgumentLocalVarName(par)#>)<#=tagValueIfTagged#>);<#=tagMarker#>

<#+
			if (par.ParameterType.IsClientObject || par.ParameterType.IsClientValueObject)
			{
				this.GetTagMarker(existingFileContent, "InvokeArgQueryInterface_" + method.ComMember.Name + "_" + par.Name, out tagMarker, out tagMethodSuffixIfTagged, out tagValueIfTagged);
#>
	if (<#=this.GetArgumentLocalVarName(par)#>.pdispVal != nullptr)
	{
		<#=this.IfFailRet#><#=tagMethodSuffixIfTagged#>(<#=this.GetArgumentLocalVarName(par)#>.pdispVal->QueryInterface(<#=par.ParameterType.ClientCallableType.ComInterfaceNamespace#>::IID_<#=par.ParameterType.ClientCallableType.ComType.Name#>, (void**)<#=this.GetArgumentLocalCntPtrName(par)#>.GetAddressOf())<#=tagValueIfTagged#>);<#=tagMarker#>
	}
<#+
			}
			index++;
		}

		if (!method.ReturnType.IsVoid)
		{
			if (index > 0)
			{
				sbInvokeParameterList.Append(", ");
			}

			sbInvokeParameterList.Append(Utility.GetArgumentAddressExpression(method.ReturnType, "_ret"));
		}
		this.GetTagMarker(existingFileContent, "Invoke_" + method.ComMember.Name, out tagMarker, out tagMethodSuffixIfTagged, out tagValueIfTagged);
#>
	<#=this.IfFailRet#><#=tagMethodSuffixIfTagged#>(<#=method.ComMember.Name#>(<#=sbInvokeParameterList.ToString()#>)<#=tagValueIfTagged#>);<#=tagMarker#>

<#+
		if (method.ReturnType.IsVoid)
		{
		}
		else if (method.ReturnType.IsComVariantType)
		{
#>
	if (pVarResult != nullptr)
	{
		*pVarResult = _ret.Detach();
	}
<#+
		}
		else if (method.ReturnType.IsClientObject || 
			method.ReturnType.IsClientValueObject ||
			method.ReturnType.FullName == "System.String")
		{
#>
	if (pVarResult != nullptr)
	{
		pVarResult->vt = <#=Utility.GetVariantVarType(method.ReturnType)#>;
		pVarResult-><#=Utility.GetVariantMemberName(method.ReturnType)#> = _ret.Detach();
	}
<#+
		}
		else
		{
			string cast = string.Empty;
			if (method.ReturnType.IsEnum && !method.ReturnType.IsNullable)
			{
				cast = "(LONG)";
			}
#>
	if (pVarResult != nullptr)
	{
		pVarResult->vt = <#=Utility.GetVariantVarType(method.ReturnType)#>;
		pVarResult-><#=Utility.GetVariantMemberName(method.ReturnType)#> = <#=cast#>_ret;
	}
<#+
		}
#>
	return S_OK;
}
<#+
	}

	void WriteUtilityClass(string existingFilePath)
	{
		string[] existingFileContent = this.GetExistingFileContent(existingFilePath);
		this.WritePreIncludes();
		this.WriteIncludes();
#>
#include "RichApi.h"
#include "<#=this.FileBaseName#><#=this.FileNamePostfix#>.h"

<#+
		List<string> namespaceStack = new List<string>();
		this.EnsureNamespace(namespaceStack, this.ImplNamespace, forTypeScript: false, indentString: Constants.IndentString);
		string tagMarker, tagMethodSuffixIfTagged, tagValueIfTagged;
		this.GetTagMarker(existingFileContent, "UtilityVariantChangeType", out tagMarker, out tagMethodSuffixIfTagged, out tagValueIfTagged);
#>
HRESULT Utility::GetArgument(const ::DISPPARAMS* pDispParams, UINT index, VARTYPE vt, /*out*/ Mso::VariantHolder& varOut) MSONOTHROW
{
	<#=this.IfFailRet#><#=tagMethodSuffixIfTagged#>(OfficeExtension::ServerRuntime::RichApi::GetDispatchArgument(pDispParams, index, vt, /*out*/ varOut)<#=tagValueIfTagged#>);<#=tagMarker#>
	return S_OK;
}

<#+
		this.WritePlaceHolderContent("Utility_ExtraFunctions", existingFileContent);
		this.EnsureNamespace(namespaceStack, string.Empty, forTypeScript: false, indentString: Constants.IndentString);
	}

	void WriteHostCreateInstance(AssemblyReader assemblyReader, string existingFilePath)
	{
		string[] existingFileContent = this.GetExistingFileContent(existingFilePath);
		this.WritePreIncludes();
		this.WriteIncludes();
#>
#include <RichApi.h>
#include "<#=this.FileBaseName#><#=this.FileNamePostfix#>.h"
<#+
		this.WritePlaceHolderContent("AdditionalHeader", existingFileContent);
		List<string> namespaceStack = new List<string>();
		this.EnsureNamespace(namespaceStack, this.ImplNamespace, forTypeScript: false, indentString: Constants.IndentString);
		string tagMarker, tagMethodSuffixIfTagged, tagValueIfTagged;
		this.GetTagMarker(existingFileContent, "Assert", out tagMarker, out tagMethodSuffixIfTagged, out tagValueIfTagged);
#>

HRESULT <#=this.RichApiHostClassName#>::CreateInstance(CLSID clsid, IID iid, void** ppv) const MSONOTHROW
{
	Assert<#=tagMethodSuffixIfTagged#>(ppv != nullptr<#=tagValueIfTagged#>);<#=tagMarker#>
	*ppv = nullptr;

<#+
		this.PushIndent(Constants.IndentString);
		this.WritePlaceHolderContent("CreateInstanceMethodHeader", existingFileContent);
		this.PopIndent();
		this.WriteLine(string.Empty);
		bool first = true;
		foreach(ClientCallableTypeInfo type in assemblyReader.Types.Where(t => t.AllowCreation && t.CoClassId != Guid.Empty))
		{
			this.GetTagMarker(existingFileContent, "New" + type.Name, out tagMarker, out tagMethodSuffixIfTagged, out tagValueIfTagged);
#>
	<#=first? "": "else "#>if (clsid == <#=type.ComInterfaceNamespace#>::CLSID_<#=type.ComType.CoClassName#>)
	{
<#+
			if (string.IsNullOrEmpty(this.NewObjMacro))
			{
#>
		Mso::TCntPtr<<#=type.ComInterfaceNamespace#>::<#=type.ComType.Name#>> spObj = new <#=this.ImplNamespace#>::<#=type.ComType.CoClassName#>(<#=this.NewObjArg#>);
<#+
			}
			else
			{
#>
		Mso::TCntPtr< <#=type.ComInterfaceNamespace#>::<#=type.ComType.Name#> > spObj = <#=this.NewObjMacro#>(<#=this.ImplNamespace#>::<#=type.ComType.CoClassName#><#=string.IsNullOrEmpty(this.NewObjArg)? "" :", "#><#=this.NewObjArg#>);
<#+
			}

			if (!string.IsNullOrEmpty(this.MemFailRet))
			{
				this.GetTagMarker(existingFileContent, "NewFail" + type.Name, out tagMarker, out tagMethodSuffixIfTagged, out tagValueIfTagged);
#>
		<#=this.MemFailRet#><#=tagMethodSuffixIfTagged#>(spObj<#=tagValueIfTagged#>);<#=tagMarker#>
<#+
			}

			this.GetTagMarker(existingFileContent, "Query" + type.Name, out tagMarker, out tagMethodSuffixIfTagged, out tagValueIfTagged);
#>
		<#=this.IfFailRet#><#=tagMethodSuffixIfTagged#>(spObj->QueryInterface(iid, ppv)<#=tagValueIfTagged#>);<#=tagMarker#>
		return S_OK;
	}
<#+	
			first = false;
		}
		this.PushIndent(Constants.IndentString);
		this.WriteLine(string.Empty);
		this.WritePlaceHolderContent("CreateInstanceMethodReturn", existingFileContent, "return CLASS_E_CLASSNOTAVAILABLE;");
		this.PopIndent();
#>
}

<#+
		this.EnsureNamespace(namespaceStack, string.Empty, forTypeScript: false, indentString: Constants.IndentString);
	}

	string[] GetExistingFileContent(string existingFilePath)
	{
		string[] existingFileContent = new string[0];
		if (File.Exists(existingFilePath))
		{
			existingFileContent = File.ReadAllLines(existingFilePath);
		}
		return existingFileContent;
	}

	void GetTagMarker(string[] existingContent, string tagId, out string tagMarker, out string tagMethodSuffixIfTagged, out string tagValueIfTagged)
	{
		tagMethodSuffixIfTagged = string.Empty;
		tagValueIfTagged = string.Empty;

		tagMarker = " // <TagMarker>" + tagId + "</TagMarker>";
		int indexMarkerLine = -1;
		for (int i = 0; i < existingContent.Length; i++)
		{
			if (existingContent[i].IndexOf(tagMarker) >= 0)
			{
				indexMarkerLine = i;
				break;
			}
		}

		if (indexMarkerLine >= 0)
		{
			string tagLine = existingContent[indexMarkerLine];
			System.Text.RegularExpressions.Match match = System.Text.RegularExpressions.Regex.Match(tagLine, @"0x[a-fA-F\d]+\s*/\*\s*tag_\S+\s*\*/");
			if (match.Success)
			{
				tagMethodSuffixIfTagged = "Tag";
				tagValueIfTagged = ", " + match.Value;
			}
		}
	}

#>
