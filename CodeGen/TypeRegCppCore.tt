<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Globalization" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="Helper.tt" #>
<#@ include file="Core.tt" #>
<#@ output extension=".txt" #>
<#+	
	private void WriteTypeRegistration()
	{
		this.LaunchDebuggerIfNecessary();
		if (this.CheckInputParameters())
		{
			CodeGenTemplateFileManager templateFileManager = new CodeGenTemplateFileManager(this.GenerationEnvironment);
			templateFileManager.StartHeader();

#>
/*
 * This is a generated file. <#=this.CreatedByToolStatement#>
 * If there are content placeholders, only edit content inside content placeholders.
 * If there are no content placeholders, do not edit this file directly.
 */

<#+
			templateFileManager.EndBlock();
			templateFileManager.StartNewFile(this.FileBaseName + "TypeReg" + this.FileNamePostfix + ".h");
			this.WriteTypeRegistrationHeader();
			templateFileManager.EndBlock();

			templateFileManager.StartNewFile(this.FileBaseName + "TypeReg" + this.FileNamePostfix + ".cpp");
			this.WriteTypeRegistrationClass(System.IO.Path.Combine(this.OutputDirectory, this.FileBaseName + "TypeReg" + this.FileNamePostfix + ".cpp"));
			templateFileManager.EndBlock();

			templateFileManager.WriteTo(this.OutputDirectory, this.CheckoutCommandPrefix);
		}
	}

	private void WriteTypeRegistrationHeader()
	{
#>
#pragma once
namespace OfficeExtension
{
	namespace ServerRuntime
	{
		class ITypeRegistration;
	}
}

<#+
		List<string> namespaceStack = new List<string>();
		this.EnsureNamespace(namespaceStack, this.ImplNamespace, forTypeScript: false, indentString: Constants.IndentString);
#>
class TypeReg
{
public:
	static void RegisterTypes(OfficeExtension::ServerRuntime::ITypeRegistration& typeReg);
private:
	TypeReg();
};
<#+
		this.EnsureNamespace(namespaceStack,string.Empty, forTypeScript: false, indentString: Constants.IndentString);
	}

	private void WriteTypeRegistrationClass(string filePath)
	{		
		foreach (string include in this.AdditionalPreIncludes)
		{
#>
#include "<#=include#>"
<#+
		}
#>
<#+
		foreach (string include in this.AdditionalIncludes)
		{
#>
#include "<#=include#>"
<#+
		}
		string headerFileName = this.FileBaseName + "TypeReg" + this.FileNamePostfix + ".h";
#>
#include "<#=headerFileName#>"
<#+
		foreach (string usingNs in this.AdditionalUsings)
		{
#>
using namespace <#=usingNs#>;
<#+
		}
#>

<#+
		string[] existingFileContent = new string[0];
		if (File.Exists(filePath))
		{
			existingFileContent = File.ReadAllLines(filePath);
		}

		this.WriteLine(string.Empty);
		this.WritePlaceHolderContent("GlobalHeader", existingFileContent);
		this.WriteLine(string.Empty);

		List<string> namespaceStack = new List<string>();
		this.EnsureNamespace(namespaceStack, this.ImplNamespace, forTypeScript: false, indentString: Constants.IndentString);

		AssemblyReader reader = new AssemblyReader(this.InputFilePath, null, this.ReferencedAssemblyPaths, this.MaxVersion);
		reader.Process();

		string defaultNamespace = reader.Types.First().Namespace;

		foreach (ClientCallableTypeInfo typeInfo in reader.Types.Where(t => !t.IsEnum && t.ComType != null))
		{
			foreach (ClientCallablePropertyInfo prop in typeInfo.Properties)
			{
				WriteErrorCodeData("s_" + typeInfo.Name + "_" + prop.Name + "_ErrorCodes", prop.HResultErrors);
			}

			foreach (ClientCallableMethodInfo method in typeInfo.Methods)
			{
				WriteErrorCodeData("s_" + typeInfo.Name + "_" + method.Name + "_ErrorCodes", method.HResultErrors);
			}
		}

		foreach (ClientCallableTypeInfo typeInfo in reader.Types.Where(t => !t.IsEnum && t.ComType != null))
		{
			this.WriteTypePropertyData(typeInfo, defaultNamespace);
			this.WriteTypeMethodData(typeInfo, defaultNamespace);
		}

		foreach (ClientCallableTypeInfo typeInfo in reader.Types.Where(t => t.IsEnum))
		{
			this.WriteEnumTypeFiledData(typeInfo);
		}

#>
static const OfficeExtension::ServerRuntime::ApiTypeData s_typeRegTypes[] = 
{
<#+
		foreach (ClientCallableTypeInfo typeInfo in reader.Types.Where(t => !t.IsEnum && t.ComType != null))
		{
			string classId = string.Empty;
			if (typeInfo.CoClassId != Guid.Empty)
			{
				classId = typeInfo.CoClassId.ToString("B");
			}

			string createItemOperationName = string.Empty;
			string deleteOperationName = string.Empty;
			string childItemClientType = string.Empty;
			string supportEnumeration = "false";
			if (typeInfo.IsClientObject)
			{
				createItemOperationName = typeInfo.CreateItemOperationName ?? string.Empty;
				deleteOperationName = typeInfo.DeleteOperationName ?? string.Empty;

				if (typeInfo.ClientType.ChildItemClientType != null)
				{
					childItemClientType = GetTypeRegistrationName(typeInfo.ClientType.ChildItemClientType, defaultNamespace);
					supportEnumeration = Utility.GetBooleanLiteral(typeInfo.ComType.SupportEnumeration);
				}
			}

			string propertyCount = "0";
			string properties = "nullptr";
			if (typeInfo.Properties.Count > 0)
			{
				properties = "s_" + typeInfo.Name + "_Properties";
				propertyCount = "_countof(" + properties + ")";
			}

			string methodCount = "0";
			string methods = "nullptr";
			if (typeInfo.Methods.Count > 0)
			{
				methods = "s_" + typeInfo.Name + "_Methods";
				methodCount = "_countof(" + methods + ")";
			}

			string typeFlags;
			if (typeInfo.UseItemAsIndexerNameInODataId)
			{
				typeFlags = "OfficeExtension::ServerRuntime::TypeFlags::UseItemAsIndexerNameInODataId";
			}
			else
			{
				typeFlags = "OfficeExtension::ServerRuntime::TypeFlags::None";
			}

#>
	{ "<#=GetTypeRegistrationName(typeInfo.ClientType, defaultNamespace)#>", "<#=typeInfo.InterfaceId.ToString("B")#>", /*ClassId*/ "<#=classId#>", /*CreateItemOperatioName*/ "<#=createItemOperationName#>", /*DeleteOperationName*/ "<#=deleteOperationName#>", /*ChildItemTypeName*/ "<#=childItemClientType#>", /*Properties*/ <#=properties#>, /*Methods*/ <#=methods#>, /*PropertyCount*/ <#=propertyCount#>, /*MethodCount*/ <#=methodCount#>, OfficeExtension::ServerRuntime::TypeCategory::<#=typeInfo.IsValueObject ? "ValueObject" : "ClassObject"#>, /*ShouldConvertIntKeyValueToString*/ <#=Utility.GetBooleanLiteral(typeInfo.ConvertIntegerKeyValueToString)#>, /*SupportEnumeration*/ <#=supportEnumeration#>, /*Flags*/ <#=typeFlags#> },
<#+		
		}
#>
};

<#+
		bool useTemplate = true;
		string enumTypeCount = "0";
		string enumTypes = "nullptr";
		if (reader.Types.Where(t => t.IsEnum).Count() > 0)
		{
			enumTypeCount = "_countof(s_typeRegEnumTypes)";
			enumTypes = "s_typeRegEnumTypes";
#>
static const OfficeExtension::ServerRuntime::ApiEnumTypeData s_typeRegEnumTypes[] = 
{
<#+
			foreach (ClientCallableTypeInfo typeInfo in reader.Types.Where(t => t.IsEnum))
			{
#>
	{ "<#=GetTypeRegistrationName(typeInfo.ClientType, defaultNamespace)#>", /*Fields*/ s_<#=typeInfo.Name#>_Fields, /*FieldsCount*/ _countof(s_<#=typeInfo.Name#>_Fields) },
<#+			
			}
#>
};
<#+	
		}
		else
		{
			useTemplate = false;
		}

		WriteErrorCodeData("s_typeRegGlobalErrorCodes", reader.HResultErrors);
		string errorCount = "0";
		string errors = "nullptr";
		if (reader.HResultErrors.Count > 0)
		{
			errors = "s_typeRegGlobalErrorCodes";
			errorCount = "_countof(s_typeRegGlobalErrorCodes)";
		}
		else
		{
			useTemplate = false;
		}

#>

/*static*/
void TypeReg::RegisterTypes(OfficeExtension::ServerRuntime::ITypeRegistration& typeReg)
{
<#+
		if (useTemplate)
		{
#>
	OfficeExtension::ServerRuntime::ITypeRegistration::AddApiDataHelper(typeReg, "<#=defaultNamespace#>", s_typeRegTypes, <#=enumTypes#>, <#=errors#>, 7422);
<#+
		}
		else
		{
#>
	typeReg.AddApiData("<#=defaultNamespace#>", s_typeRegTypes, _countof(s_typeRegTypes), <#=enumTypes#>, <#=enumTypeCount#>, <#=errors#>, <#=errorCount#>, 7422);
<#+
		}
#>
}
<#+
		this.EnsureNamespace(namespaceStack, string.Empty, forTypeScript: false, indentString: Constants.IndentString);
		this.WriteLine(string.Empty);

		this.WritePlaceHolderContent("GlobalFooter", existingFileContent);
		this.WriteLine(string.Empty);
	}


	private void WriteEnumTypeFiledData(ClientCallableTypeInfo typeInfo)
	{
#>

// enum fields for <#=typeInfo.Name#>
static const OfficeExtension::ServerRuntime::ApiEnumTypeFieldData s_<#=typeInfo.Name#>_Fields[] =
{
<#+
		foreach (KeyValuePair<string, int> field in typeInfo.EnumFields)
		{
#>
	{ "<#=Utility.TrimUnderscore(field.Key)#>", /*Value*/ <#=field.Value#> },
<#+
		}
#>
};
<#+
	}


	private void WriteTypePropertyData(ClientCallableTypeInfo typeInfo, string defaultNamespace)
	{
		if (typeInfo.Properties.Count == 0)
		{
			return;
		}

#>

// properties for <#=typeInfo.Name#>
static const OfficeExtension::ServerRuntime::ApiPropertyData s_<#=typeInfo.Name#>_Properties[] =
{
<#+
		foreach (ClientCallablePropertyInfo propInfo in typeInfo.Properties)
		{
			string knownTypeName = "nullptr";
			if (propInfo.KnownType != null)
			{
				knownTypeName = "\"" + GetTypeRegistrationName(propInfo.KnownType, defaultNamespace) + "\"";
			}

			string apiErrorCodeCount = "0";
			string apiErrorCodes = "nullptr";
			if (propInfo.HResultErrors.Count > 0)
			{
				apiErrorCodes = "s_" + typeInfo.Name + "_" + propInfo.Name + "_ErrorCodes";
				apiErrorCodeCount = "_countof(" + apiErrorCodes + ")";
			}
#>
	{"<#=propInfo.Name#>", "<#=GetTypeRegistrationName(propInfo.PropertyType, defaultNamespace)#>", /*KnownTypeName*/ <#=knownTypeName#>, /*ErrorCodes*/ <#=apiErrorCodes#>, /*DispatchId*/ <#=propInfo.ComMember.DispatchId.ToString(CultureInfo.InvariantCulture)#>, /*ErrorCodeCount*/ <#=apiErrorCodeCount#>, OfficeExtension::ServerRuntime::TypeCategory::<#=propInfo.PropertyType.TypeRegistrationTypeCategory#>, /*IsReadonly*/ <#=Utility.GetBooleanLiteral(propInfo.IsReadonly)#>, /*ExcludedFromRest*/ <#=Utility.GetBooleanLiteral(propInfo.ExcludedFromRest)#> },
<#+
		}
#>
};
<#+
	}

	private void WriteTypeMethodData(ClientCallableTypeInfo typeInfo, string defaultNamespace)
	{
		if (typeInfo.Methods.Count == 0)
		{
			return;
		}

		foreach (ClientCallableMethodInfo methodInfo in typeInfo.Methods.Where(m => m.Parameters.Count > 0))
		{
#>

// parameters for <#=typeInfo.Name#>.<#=methodInfo.Name#>
static const OfficeExtension::ServerRuntime::ApiParameterData s_<#=typeInfo.Name#>_<#=methodInfo.Name#>_Parameters[] = 
{
<#+
			foreach (ClientCallableParameterInfo paraInfo in methodInfo.Parameters)
			{
				string knownTypeName = "nullptr";
				if (paraInfo.KnownType != null)
				{
					knownTypeName = "\"" + GetTypeRegistrationName(paraInfo.KnownType, defaultNamespace) + "\"";
				}
#>
	{ "<#=paraInfo.Name#>", "<#=GetTypeRegistrationName(paraInfo.ParameterType, defaultNamespace)#>", /*KnownTypeName*/ <#=knownTypeName#>, OfficeExtension::ServerRuntime::TypeCategory::<#=paraInfo.ParameterType.TypeRegistrationTypeCategory#> },
<#+
			}
#>
};
<#+
		}
		

#>

// methods for <#=typeInfo.Name#>
static const OfficeExtension::ServerRuntime::ApiMethodData s_<#=typeInfo.Name#>_Methods[] =
{
<#+
		foreach (ClientCallableMethodInfo methodInfo in typeInfo.Methods)
		{
			string methodParameterCount = "0";
			string methodParameters = "nullptr";
			if (methodInfo.Parameters.Count > 0)
			{
				methodParameters = "s_" + typeInfo.Name + "_" + methodInfo.Name + "_Parameters";
				methodParameterCount = "_countof(" + methodParameters + ")";
			}

			string apiErrorCodeCount = "0";
			string apiErrorCodes = "nullptr";
			if (methodInfo.HResultErrors.Count > 0)
			{
				apiErrorCodes = "s_" + typeInfo.Name + "_" + methodInfo.Name + "_ErrorCodes";
				apiErrorCodeCount = "_countof(" + apiErrorCodes + ")";
			}

			string methodName = methodInfo.Name;
			if (methodInfo.IsIndexerMethod)
			{
				methodName = ".indexer";
			}
#>
	{ "<#=methodName#>", "<#=GetTypeRegistrationName(methodInfo.ReturnType, defaultNamespace)#>", "<#=methodInfo.RESTfulName#>", /*Parameters*/ <#=methodParameters#>, /*ErrorCodes*/ <#=apiErrorCodes#>, /*DispatchId*/ <#=methodInfo.ComMember.DispatchId.ToString(CultureInfo.InvariantCulture)#>, <#=this.GetDispatchFlagExpression(methodInfo.ComMember.DispatchFlag)#>, /*ParameterCount*/ <#=methodParameterCount#>, /*ErrorCodeCount*/ <#=apiErrorCodeCount#>, OfficeExtension::ServerRuntime::OperationType::<#=methodInfo.OperationType#>, OfficeExtension::ServerRuntime::TypeCategory::<#=methodInfo.ReturnType.TypeRegistrationTypeCategory#> },
<#+
		}
#>
};
<#+
	}

	private void WriteErrorCodeData(string varName, List<HResultErrorInfo> errorInfos)
	{
		if (errorInfos.Count == 0)
		{
			return;
		}
#>

// error codes for <#=varName#>
static const OfficeExtension::ServerRuntime::ApiErrorCodeData <#=varName#>[] = 
{
<#+		
		foreach (HResultErrorInfo errorInfo in errorInfos)
		{
#>
	{ "<#=errorInfo.ErrorCode#>", <#=errorInfo.HResultExpression#>, <#=errorInfo.StatusCode#>, <#=errorInfo.ErrorMessageId#> },
<#+
		}
#>
};
<#+
	}

	private string GetTypeRegistrationName(ClientType type, string defaultNamesapce)
	{
		string ret = type.TypeRegistrationTypeName;
		if (ret.Length > defaultNamesapce.Length &&
			ret.StartsWith(defaultNamesapce, StringComparison.Ordinal) &&
			ret[defaultNamesapce.Length] == '.')
		{
			ret = ret.Substring(defaultNamesapce.Length);
		}

		return ret;
	}

	private string GetDispatchFlagExpression(int dispatchFlag)
	{
		StringBuilder sb = new StringBuilder();
		if (0 != (dispatchFlag & Constants.DISPATCH_METHOD))
		{
			if (sb.Length > 0)
			{
				sb.Append("|");
			}

			sb.Append("DISPATCH_METHOD");
		}

		if (0 != (dispatchFlag & Constants.DISPATCH_PROPERTYGET))
		{
			if (sb.Length > 0)
			{
				sb.Append("|");
			}

			sb.Append("DISPATCH_PROPERTYGET");
		}

		if (0 != (dispatchFlag & Constants.DISPATCH_PROPERTYPUT))
		{
			if (sb.Length > 0)
			{
				sb.Append("|");
			}

			sb.Append("DISPATCH_PROPERTYPUT");
		}

		if (sb.Length == 0)
		{
			return "0";
		}

		return sb.ToString();
	}

#>