<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Globalization" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="Helper.tt" #>
<#@ include file="Core.tt" #>
<#@ output extension=".txt" #>
<#+	
	private void WriteTypeRegistration()
	{
		this.LaunchDebuggerIfNecessary();
		if (this.CheckInputParameters())
		{
			CodeGenTemplateFileManager templateFileManager = new CodeGenTemplateFileManager(this.GenerationEnvironment);
			templateFileManager.StartHeader();

#>
/*
 * This is a generated file. <#=this.CreatedByToolStatement#>
 * If there are content placeholders, only edit content inside content placeholders.
 * If there are no content placeholders, do not edit this file directly.
 */

<#+
			templateFileManager.EndBlock();
			templateFileManager.StartNewFile(this.FileBaseName + "TypeReg.h");
			this.WriteTypeRegistrationHeader();
			templateFileManager.EndBlock();

			templateFileManager.StartNewFile(this.FileBaseName + "TypeReg.cpp");
			this.WriteTypeRegistrationClass(System.IO.Path.Combine(this.OutputDirectory, this.FileBaseName + "TypeReg.cpp"));
			templateFileManager.EndBlock();

			templateFileManager.WriteTo(this.OutputDirectory, this.CheckoutCommandPrefix);
		}
	}

	private void WriteTypeRegistrationHeader()
	{
#>
#pragma once
namespace OfficeExtension
{
	namespace ServerRuntime
	{
		class ITypeRegistration;
	}
}

<#+
		List<string> namespaceStack = new List<string>();
		this.EnsureNamespace(namespaceStack, this.ImplNamespace, forTypeScript: false, indentString: Constants.IndentString);
#>
class TypeReg
{
public:
	static void RegisterTypes(OfficeExtension::ServerRuntime::ITypeRegistration& typeReg);
private:
	TypeReg();
};
<#+
		this.EnsureNamespace(namespaceStack,string.Empty, forTypeScript: false, indentString: Constants.IndentString);
	}

	private void WriteTypeRegistrationClass(string filePath)
	{		
		foreach (string include in this.AdditionalPreIncludes)
		{
#>
#include "<#=include#>"
<#+
		}
#>
<#+
		foreach (string include in this.AdditionalIncludes)
		{
#>
#include "<#=include#>"
<#+
		}
		string headerFileName = this.FileBaseName + "TypeReg.h";
#>
#include "<#=headerFileName#>"
<#+
		foreach (string usingNs in this.AdditionalUsings)
		{
#>
using namespace <#=usingNs#>;
<#+
		}
#>

<#+
		string[] existingFileContent = new string[0];
		if (File.Exists(filePath))
		{
			existingFileContent = File.ReadAllLines(filePath);
		}

		this.WriteLine(string.Empty);
		this.WritePlaceHolderContent("GlobalHeader", existingFileContent);
		this.WriteLine(string.Empty);

		List<string> namespaceStack = new List<string>();
		this.EnsureNamespace(namespaceStack, this.ImplNamespace, forTypeScript: false, indentString: Constants.IndentString);
#>
/*static*/
void TypeReg::RegisterTypes(OfficeExtension::ServerRuntime::ITypeRegistration& typeReg)
{
<#+
		AssemblyReader reader = new AssemblyReader(this.InputFilePath, null, this.ReferencedAssemblyPaths);
		reader.Process();
		WriteAddErrorCodeInformation("typeReg", reader.HResultErrors);
		foreach (ClientCallableTypeInfo typeInfo in reader.Types)
		{
			WriteType(typeInfo);
		}
#>
}
<#+
		this.EnsureNamespace(namespaceStack, string.Empty, forTypeScript: false, indentString: Constants.IndentString);
		this.WriteLine(string.Empty);

		this.WritePlaceHolderContent("GlobalFooter", existingFileContent);
		this.WriteLine(string.Empty);
	}

	private void WriteType(ClientCallableTypeInfo typeInfo)
	{
		if (typeInfo.IsEnum)
		{
			WriteEnumType(typeInfo);
		}
		else
		{
			WriteClientObjectAndClientValueObjectType(typeInfo);
		}
	}

	private void WriteEnumType(ClientCallableTypeInfo typeInfo)
	{
		string typeVarName = "type" + typeInfo.Name;
#>
	OfficeExtension::ServerRuntime::ITypeInformation& <#=typeVarName#> = typeReg.AddEnumType(L"<#=typeInfo.FullName#>");
<#+
		foreach (KeyValuePair<string, int> field in typeInfo.EnumFields)
		{
#>
	<#=typeVarName#>.AddEnumField(L"<#=Utility.TrimUnderscore(field.Key)#>", <#=field.Value#>);
<#+
		}
	}

	private void WriteClientObjectAndClientValueObjectType(ClientCallableTypeInfo typeInfo)
	{
		string typeVarName = "type" + typeInfo.Name;
		string classId = string.Empty;
		if (typeInfo.CoClassId != Guid.Empty)
		{
			classId = typeInfo.CoClassId.ToString("B");
		}
#>

	OfficeExtension::ServerRuntime::ITypeInformation& <#=typeVarName#> = typeReg.AddType(L"<#=typeInfo.FullName#>", L"<#=typeInfo.InterfaceId.ToString("B")#>", L"<#=classId#>", OfficeExtension::ServerRuntime::TypeCategory::<#=typeInfo.IsValueObject ? "ValueObject" : "ClassObject"#>, <#=Utility.GetBooleanLiteral(typeInfo.ConvertIntegerKeyValueToString)#>);
<#+	
		foreach (ClientCallablePropertyInfo propInfo in typeInfo.Properties)
		{
			string propertyVarName = "prop" + typeInfo.Name + propInfo.Name;
			string propertyVarDeclPrefix = string.Empty;
			if (propInfo.HResultErrors.Count > 0)
			{
				propertyVarDeclPrefix = "OfficeExtension::ServerRuntime::IPropertyInformation& " + propertyVarName + " = ";
			}

			string knownTypeName = "nullptr";
			if (propInfo.KnownType != null)
			{
				knownTypeName = "L\"" + propInfo.KnownType.TypeRegistrationTypeName + "\"";
			}

#>
	<#=propertyVarDeclPrefix#><#=typeVarName#>.AddProperty(L"<#=propInfo.Name#>", <#=propInfo.ComMember.DispatchId.ToString(CultureInfo.InvariantCulture)#>, L"<#=propInfo.PropertyType.TypeRegistrationTypeName#>", OfficeExtension::ServerRuntime::TypeCategory::<#=propInfo.PropertyType.TypeRegistrationTypeCategory#>, <#=propInfo.IsReadonly? "true" :"false"#>, <#=propInfo.ExcludedFromRest? "true" :"false"#>, <#=knownTypeName#>);
<#+
			WriteAddErrorCodeInformation(propertyVarName, propInfo.HResultErrors);
		}

		foreach (ClientCallableMethodInfo methodInfo in typeInfo.Methods)
		{
			string methodVarName = "method" + typeInfo.Name + methodInfo.Name;
			string methodVarDeclPrefix = string.Empty;
			if (methodInfo.Parameters.Count > 0 || methodInfo.HResultErrors.Count > 0)
			{
				methodVarDeclPrefix = "OfficeExtension::ServerRuntime::IMethodInformation& " + methodVarName + " = ";
			}

			if (methodInfo.IsIndexerMethod)
			{
#>
	<#=methodVarDeclPrefix#><#=typeVarName#>.AddIndexerMethod(<#=methodInfo.ComMember.DispatchId.ToString(CultureInfo.InvariantCulture)#>, L"<#=methodInfo.ReturnType.TypeRegistrationTypeName#>", OfficeExtension::ServerRuntime::TypeCategory::<#=methodInfo.ReturnType.TypeRegistrationTypeCategory#>, <#=this.GetDispatchFlagExpression(methodInfo.ComMember.DispatchFlag)#>);
<#+
			}
			else
			{
#>
	<#=methodVarDeclPrefix#><#=typeVarName#>.AddMethod(L"<#=methodInfo.Name#>", <#=methodInfo.ComMember.DispatchId.ToString(CultureInfo.InvariantCulture)#>, L"<#=methodInfo.ReturnType.TypeRegistrationTypeName#>", OfficeExtension::ServerRuntime::TypeCategory::<#=methodInfo.ReturnType.TypeRegistrationTypeCategory#>, <#=this.GetDispatchFlagExpression(methodInfo.ComMember.DispatchFlag)#>, OfficeExtension::ServerRuntime::OperationType::<#=methodInfo.OperationType#>, L"<#=methodInfo.RESTfulName#>");
<#+
			}

			foreach(ClientCallableParameterInfo par in methodInfo.Parameters)
			{
				string knownTypeName = "nullptr";
				if (par.KnownType != null)
				{
					knownTypeName = "L\"" + par.KnownType.TypeRegistrationTypeName + "\"";
				}
#>
	<#=methodVarName#>.AddParameter(L"<#=par.Name#>", L"<#=par.ParameterType.TypeRegistrationTypeName#>", OfficeExtension::ServerRuntime::TypeCategory::<#=par.ParameterType.TypeRegistrationTypeCategory#>, <#=knownTypeName#>);
<#+
			}

			WriteAddErrorCodeInformation(methodVarName, methodInfo.HResultErrors);
		}

		if (typeInfo.IsClientObject)
		{
			if (!string.IsNullOrEmpty(typeInfo.CreateItemOperationName) ||
				!string.IsNullOrEmpty(typeInfo.DeleteOperationName))
			{
#>
	<#=typeVarName#>.SetRESTfulOperationMethodNames(L"<#=typeInfo.CreateItemOperationName ?? string.Empty#>", L"<#=typeInfo.DeleteOperationName ?? string.Empty#>");
<#+
			}

			if (typeInfo.ClientType.ChildItemClientType != null)
			{
#>
	<#=typeVarName#>.SetCollectionInfo(L"<#=typeInfo.ClientType.ChildItemClientType.TypeRegistrationTypeName#>", <#=Utility.GetBooleanLiteral(typeInfo.ComType.SupportEnumeration)#>);
<#+
			}
		}
	}

	private void WriteAddErrorCodeInformation(string prefix, List<HResultErrorInfo> errorInfos)
	{
		foreach (HResultErrorInfo errorInfo in errorInfos)
		{
#>
	<#=prefix#>.AddErrorCodeInformation(<#=errorInfo.HResultExpression#>, <#=errorInfo.StatusCode#>, L"<#=errorInfo.ErrorCode#>", <#=errorInfo.ErrorMessageId#>);
<#+
		}
	}

	private string GetDispatchFlagExpression(int dispatchFlag)
	{
		StringBuilder sb = new StringBuilder();
		if (0 != (dispatchFlag & Constants.DISPATCH_METHOD))
		{
			if (sb.Length > 0)
			{
				sb.Append("|");
			}

			sb.Append("DISPATCH_METHOD");
		}

		if (0 != (dispatchFlag & Constants.DISPATCH_PROPERTYGET))
		{
			if (sb.Length > 0)
			{
				sb.Append("|");
			}

			sb.Append("DISPATCH_PROPERTYGET");
		}

		if (0 != (dispatchFlag & Constants.DISPATCH_PROPERTYPUT))
		{
			if (sb.Length > 0)
			{
				sb.Append("|");
			}

			sb.Append("DISPATCH_PROPERTYPUT");
		}

		if (sb.Length == 0)
		{
			return "0";
		}

		return sb.ToString();
	}

#>